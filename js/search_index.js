var search_data = {"index":{"searchIndex":["actioncontroller","base","actionview","base","partials","partialrenderer","newrelic","agent","agent","classmethods","instancemethods","connect","start","startworkerthread","backgroundloadingerror","beaconconfiguration","browsermonitoring","dummymetricframe","busycalculator","database","connectionmanager","obfuscator","errorcollector","noticeerror","forcedisconnectexception","forcerestartexception","instrumentation","activerecordinstrumentation","controllerinstrumentation","classmethods","datamapperinstrumentation","memcache","metricframe","pop","queuetime","rack","rails3","actioncontroller","actionview","partialrenderer","errors","sinatra","licenseexception","methodtracer","classmethods","addmethodtracer","instancemethods","traceexecutionscoped","posttoobigexception","sampler","unsupported","samplers","cpusampler","delayedjoblocksampler","memorysampler","base","javaheapsampler","procstatus","shellps","objectsampler","serverconnectionexception","servererror","shimagent","slowsql","sqlsampler","sqltrace","statsengine","gcprofiler","profiler","railsbench","rubinius","ruby19","metricstats","harvest","synchronizedhash","samplers","scopestackelement","transactions","transactioninfo","transactionsamplebuilder","transactionsampler","transactionsqldata","workerloop","apdexstats","basicstats","chainedcall","collectionhelper","command","commandfailure","deployments","install","control","classmethods","configuration","frameworks","external","merb","rails","rails3","ruby","sinatra","instancemethods","instrumentation","loggingmethods","profiling","servermethods","dataserialization","classmethods","delayedjobinjection","instrumentation","actsassolrinstrumentation","parsermethodsinstrumentation","languagesupport","control","dataserialization","synchronizedhash","localenvironment","merbbootloader","methodtracestats","metricdata","metricspec","metrics","noticederror","rack","browsermonitoring","developermode","railtie","scopedmethodtracestats","stats","statsbase","transactionanalysis","segmentsummary","transactionsample","compositesegment","fakesegment","segment","summarysegment","urlrule","ruleset","versionnumber","object","<<()","<=>()","<=>()","==()","[]()","[]()","[]=()","[]=()","[]=()","_call()","abort_transaction!()","abort_transaction!()","abort_transaction!()","absent?()","add_called_segment()","add_custom_parameters()","add_custom_parameters()","add_custom_parameters()","add_force_persist_to()","add_harvest_sampler()","add_instrumentation()","add_instrumentation()","add_method_tracer()","add_random_sample_to()","add_request_parameters()","add_sampler()","add_samples_to()","add_segments()","add_to_error_queue()","add_transaction_tracer()","after_fork()","after_fork()","after_fork()","after_fork()","after_fork_with_newrelic()","agent()","agent_config()","agent_enabled?()","agent_instance()","aggregate()","already_started?()","any_unrecognized_keys?()","apdex_f()","apdex_f_threshold?()","apdex_score()","apdex_t()","api_server()","app()","app_names()","append_backtrace()","append_environment_info()","append_environment_info()","append_environment_info()","append_environment_value()","append_gem_list()","append_new_message()","append_plugin_list()","apply()","as_percentage()","as_percentage_of()","assemble_code_header()","autoinstrument_source()","average_call_time()","average_exclusive_time()","average_exclusive_time()","average_response_time()","average_time()","average_value()","begin_time()","begin_time=()","breakdown_data()","browser_monitoring_auto_instrument?()","browser_timing_footer()","browser_timing_footer()","browser_timing_footer()","browser_timing_header()","browser_timing_header()","browser_timing_header()","build_browser_timing_header()","build_load_file_js()","builder()","bundler_gem_list()","busy_count()","call()","call()","call()","call_count()","call_count()","call_count()","call_time()","call_time()","call_time()","call_with_newrelic()","called_segments()","called_segments=()","calls_per_minute()","can_run?()","capture()","capture()","capture_params()","capture_segment_trace()","catch_errors()","cert_file_path()","check_config_and_start_agent()","check_for_illegal_keys!()","check_for_push_scope_and_metric()","check_server_connection=()","check_sql_sampler_status()","check_transaction_sampler_status()","checked_calculation()","clamp_number_tts()","clear()","clear()","clear_builder()","clear_stats()","clear_thread_metric_frame!()","clear_transaction_data()","close_connections()","close_connections()","code_to_eval()","command()","command()","config()","config()","config()","config=()","config_file()","config_file()","config_transaction_tracer()","configure!()","configure!()","configure_error_collector!()","configure_transaction_tracer!()","connect_in_foreground()","connect_settings()","connect_to_server()","connected?()","content()","control()","convert_to_ip_address()","correct_license_length()","count_segments()","count_segments()","cpu_burn()","create_and_run_worker_loop()","create_segment()","create_transaction_data()","current()","current_metric()","current_sample_id()","current_stack_metric()","custom_parameters()","custom_parameters()","custom_params_from_opts()","database_metric_name()","database_time()","default_metric_name_code()","default_sql_obfuscator()","deferred_work!()","delete()","delete_if()","detail_segments=()","developer_mode?()","disable()","disable()","disable_all_tracing()","disable_backtrace_cleanup?()","disable_serialization=()","disable_serialization?()","disable_sql_recording()","disable_transaction_tracing()","disabled?()","disabled?()","disconnect()","dispatcher()","dispatcher_finish()","dispatcher_instance_id()","dispatcher_instance_id()","dispatcher_start()","do_not_trace?()","duration()","duration()","duration()","duration()","each()","each_segment()","each_segment()","each_segment_with_nest_tracking()","each_segment_with_nest_tracking()","enable()","enable()","enable_random_samples!()","enabled?()","enabled?()","enabled?()","enabled?()","enabled?()","end_time()","end_time=()","end_trace()","end_transaction()","end_transaction()","end_transaction!()","ensure_segment_count_set()","env()","env()","env()","env()","env()","environment_for_connect()","eql?()","eql?()","eql?()","err()","error_is_ignored?()","error_params_from_options()","exception_info()","exclusive_duration()","exclusive_time_percentage()","exclusive_time_percentage()","expand_min_max_to()","explain()","explain_sql()","explain_sql()","explain_statement()","extract_source()","extract_stack_trace()","fetch()","fetch_from_options()","filtered_by_error_filter?()","filtered_error?()","find_class_in_object_space()","find_or_create_file_path()","find_segment()","find_segment()","finish_command()","finish_setup()","finish_trace()","force_persist_sample?()","fraction_of()","framework()","freeze()","freeze()","gather_ar_adapter_info()","gather_architecture_info()","gather_cpu_info()","gather_db_info()","gather_dm_adapter_info()","gather_environment_info()","gather_jruby_info()","gather_os_info()","gather_revision_info()","gather_ruby_info()","gather_system_info()","get()","get_apdex()","get_connection()","get_connection()","get_custom_stats()","get_memory()","get_memory()","get_memory()","get_metric_stats()","get_retry_period()","get_sample()","get_stats()","get_stats()","get_stats_no_scope()","get_stats_no_scope()","get_stats_scoped()","get_stats_unscoped()","guid()","guid=()","handle_empty_path_stack()","handle_exception_in_explain()","handle_force_disconnect()","handle_force_restart()","handle_license_error()","handle_other_error()","handle_server_connection_problem()","harvest()","harvest()","harvest_busy()","harvest_errors()","harvest_slow_sql()","harvest_timeslice_data()","has_correct_license_key?()","has_license_key?()","hash()","hash()","hash()","http_connection()","ignore()","ignore_apdex?()","ignore_error_filter()","ignore_error_filter()","ignore_transaction()","ignore_transaction()","ignored?()","include_guid?()","included()","included()","included()","included()","included()","increment_count()","increment_error_count!()","info()","inherited()","inherited()","init()","init_config()","init_config()","init_config()","init_config()","init_config()","init_plugin()","initialize()","initialize_with_new_relic()","initialize_without_new_relic()","inspect()","inspect()","inspect()","install_browser_monitoring()","install_developer_mode()","install_exit_handler()","install_instrumentation()","install_shim()","install_shim()","instance()","instance()","instance()","instrument_methods()","is_execution_traced?()","is_reset?()","is_select?()","is_sql_recorded?()","is_transaction_traced?()","is_web_transaction?()","javascript_header()","jruby_cpu_burn()","keep_running()","license_bytes()","license_key()","load()","load_data()","load_framework_class()","load_instrumentation_files()","load_newrelic_yml()","load_newrelic_yml()","load_samplers()","load_test_framework()","local_env()","local_env()","lock()","locked_jobs()","log()","log()","log()","log()","log!()","log!()","log!()","log_app_names()","log_connection!()","log_dispatcher()","log_error()","log_errors()","log_file_name()","log_file_path()","log_if()","log_path()","log_seed_token()","log_sql_transmission_warning?()","log_to_stdout?()","log_underflow()","log_unless()","log_version_and_pid()","log_with_newrelic_instrumentation()","log_with_newrelic_instrumentation()","log_worker_loop_start()","logger()","logger()","logger()","lookup_stats()","main_stat()","major_version()","manual_start()","memcache_key_snippet()","merge()","merge()","merge!()","merge_attributes()","merge_data()","merge_data_from()","merge_data_from()","merge_defaults()","merge_options()","merge_server_side_config()","method_with_push_scope()","method_without_push_scope()","metric_name()","metric_spec=()","metrics()","midpoint()","min_time_less?()","minor_version()","mongrel()","monitor_mode?()","monitoring?()","multi_threaded?()","multiply_by()","need_to_explain?()","need_to_obfuscate?()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_instance()","newrelic_ignore()","newrelic_ignore_apdex()","newrelic_method_exists?()","newrelic_metric_path()","newrelic_metric_path()","newrelic_notice_error()","newrelic_notice_error()","newrelic_request_headers()","newrelic_request_headers()","newrelic_response_code()","newrelic_root()","newrelic_root()","normal_cpu_burn()","normalize()","normalize_params()","normalized_request_and_custom_params()","notice_error()","notice_error()","notice_error()","notice_first_scope_push()","notice_first_scope_push()","notice_nosql()","notice_pop_scope()","notice_profile()","notice_push_scope()","notice_scope_empty()","notice_scope_empty()","notice_scope_empty()","notice_sql()","notice_sql()","notice_transaction()","notice_transaction()","notice_transaction_cpu_time()","notify_log_file_location()","notify_transaction_sampler()","obfuscate()","obfuscate_sql()","obfuscated_sql()","omit_segments_with()","original_spec()","over_queue_limit?()","params()","params=()","params=()","parent_segment=()","parse_frontend_headers()","parse_query_with_newrelic()","path()","path_string()","path_string()","peek_scope()","perform_action_with_newrelic_trace()","pid_too_old?()","platform()","platform()","poll()","poll()","poll()","poll()","poll()","pop()","pop_flag!()","pop_scope()","pop_trace_execution_flag()","pop_trace_execution_flag()","post_size_limit()","prepare_to_send()","prepare_to_send()","proc_status_file()","process_action()","process_resultset()","profiling=()","profiling?()","profiling_available?()","proxy_server()","push()","push_flag!()","push_scope()","push_trace_execution_flag()","push_trace_execution_flag()","query_server_for_configuration()","queue_time()","queue_time()","rails_gem_list()","rails_vendor_root()","rails_version()","read_and_write_to_file()","record_apdex()","record_apdex()","record_apdex_f()","record_apdex_s()","record_apdex_t()","record_data_point()","record_gc_metric()","record_jruby_cpu_burn()","record_multiple_data_points()","record_multiple_data_points()","record_transaction()","record_transaction()","record_transaction_cpu()","recorded_metrics()","recording_web_transaction?()","recording_web_transaction?()","referer()","referer()","referer_from_request()","remove_server_controlled_configs()","remove_transaction_sampler()","render_collection()","render_partial()","render_time()","request()","request_params_from_opts()","request_with_newrelic_trace()","request_without_newrelic_trace()","requests_per_minute()","rescue_action_with_newrelic_trace()","reset()","reset()","reset()","reset()","reset()","reset!()","reset!()","reset_stats()","reset_stats()","reset_stats()","resolve_ip_address()","root()","root()","root()","root()","root()","route_eval_with_newrelic()","run()","run()","run()","run()","run()","run_task()","sample_id()","sampler_classes()","sampling_rate=()","save_data()","scope_depth()","scope_depth()","scope_name()","scope_name=()","scope_stack()","send_data_on_exit()","sense_method()","serialize()","serialize()","server()","server_from_host()","set()","set_collector_host!()","set_deduct_call_time_based_on_metric()","set_if_nil()","set_log_format!()","set_log_level!()","set_new_scope!()","set_primary()","set_profile()","set_record_sql()","set_record_tt()","set_sql_obfuscator()","set_sql_obfuscator()","set_sql_obfuscator()","set_sql_recording!()","set_transaction_cpu_time()","set_transaction_info()","set_transaction_info()","set_user_attributes()","set_user_attributes()","set_user_attributes()","settings()","setup_log()","should_exit_notice_error?()","should_instrument?()","should_keep_retrying?()","should_log?()","should_replace_begin_time?()","should_replace_end_time?()","should_retry?()","should_send_data?()","shutdown()","shutdown()","shutdown()","slowest_sample?()","snapshot()","split()","sql_segments()","stack_min_max_from()","standard_deviation()","start()","start()","start_agent()","start_builder()","start_sampler_thread()","start_time()","start_transaction()","start_transaction()","start_transaction()","started?()","stat_engine()","stats()","stats()","stats()","stats_hash()","stop()","store_force_persist()","store_random_sample()","store_sample()","store_sample_for_developer_mode()","store_slowest_sample()","store_too_large?()","store_too_old?()","strip_nr_from_backtrace()","sub()","sum_attributes()","sum_merge!()","summary()","supported_on_this_platform?()","supported_on_this_platform?()","supported_on_this_platform?()","supported_on_this_platform?()","supported_on_this_platform?()","sync_startup()","system_util_stats()","systemtime_stats()","time_percentage()","time_str()","timestamp()","tiny_version()","to_debug_str()","to_json()","to_json()","to_json()","to_json()","to_json()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s_compact()","to_s_compact()","to_stdout()","to_stdout()","to_stdout()","to_stdout()","to_stdout()","total_call_time_per_minute()","total_time_percentage()","trace_call()","trace_call()","trace_disabled?()","trace_entry()","trace_execution_scoped()","trace_execution_scoped_footer()","trace_execution_scoped_header()","trace_execution_unscoped()","trace_exit()","trace_method_execution_no_scope()","traced?()","traced?()","traced_method_exists?()","transaction_data()","transaction_sampler=()","tried_to_connect?()","truncate()","truncate()","truncate!()","truncate_each_child()","truncate_message()","truncate_samples()","ui_name()","unrecognized_keys()","unsent_errors_size()","unsent_timeslice_data()","unsent_traces_size()","update_apdex()","update_boundaries()","update_last_sent!()","update_totals()","uri()","uri_from_request()","uri_ref_and_root()","use_harvest_sampler?()","use_ssl?()","use_textmate?()","user_attributes()","user_attributes()","user_attributes()","user_util_stats()","usertime_stats()","using_engine?()","using_forking_dispatcher?()","using_sinatra?()","using_version?()","validate_options()","validate_seed()","validate_settings()","validate_token()","vendor_root()","verify_certificate?()","version()","weird_ruby?()","with_database_metric_name()","with_database_metric_name()","worker_name()","working_jruby?()","changelog","license","readme"],"longSearchIndex":["actioncontroller","actioncontroller::base","actionview","actionview::base","actionview::partials","actionview::partials::partialrenderer","newrelic","newrelic::agent","newrelic::agent::agent","newrelic::agent::agent::classmethods","newrelic::agent::agent::instancemethods","newrelic::agent::agent::instancemethods::connect","newrelic::agent::agent::instancemethods::start","newrelic::agent::agent::instancemethods::startworkerthread","newrelic::agent::backgroundloadingerror","newrelic::agent::beaconconfiguration","newrelic::agent::browsermonitoring","newrelic::agent::browsermonitoring::dummymetricframe","newrelic::agent::busycalculator","newrelic::agent::database","newrelic::agent::database::connectionmanager","newrelic::agent::database::obfuscator","newrelic::agent::errorcollector","newrelic::agent::errorcollector::noticeerror","newrelic::agent::forcedisconnectexception","newrelic::agent::forcerestartexception","newrelic::agent::instrumentation","newrelic::agent::instrumentation::activerecordinstrumentation","newrelic::agent::instrumentation::controllerinstrumentation","newrelic::agent::instrumentation::controllerinstrumentation::classmethods","newrelic::agent::instrumentation::datamapperinstrumentation","newrelic::agent::instrumentation::memcache","newrelic::agent::instrumentation::metricframe","newrelic::agent::instrumentation::metricframe::pop","newrelic::agent::instrumentation::queuetime","newrelic::agent::instrumentation::rack","newrelic::agent::instrumentation::rails3","newrelic::agent::instrumentation::rails3::actioncontroller","newrelic::agent::instrumentation::rails3::actionview","newrelic::agent::instrumentation::rails3::actionview::partialrenderer","newrelic::agent::instrumentation::rails3::errors","newrelic::agent::instrumentation::sinatra","newrelic::agent::licenseexception","newrelic::agent::methodtracer","newrelic::agent::methodtracer::classmethods","newrelic::agent::methodtracer::classmethods::addmethodtracer","newrelic::agent::methodtracer::instancemethods","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped","newrelic::agent::posttoobigexception","newrelic::agent::sampler","newrelic::agent::sampler::unsupported","newrelic::agent::samplers","newrelic::agent::samplers::cpusampler","newrelic::agent::samplers::delayedjoblocksampler","newrelic::agent::samplers::memorysampler","newrelic::agent::samplers::memorysampler::base","newrelic::agent::samplers::memorysampler::javaheapsampler","newrelic::agent::samplers::memorysampler::procstatus","newrelic::agent::samplers::memorysampler::shellps","newrelic::agent::samplers::objectsampler","newrelic::agent::serverconnectionexception","newrelic::agent::servererror","newrelic::agent::shimagent","newrelic::agent::slowsql","newrelic::agent::sqlsampler","newrelic::agent::sqltrace","newrelic::agent::statsengine","newrelic::agent::statsengine::gcprofiler","newrelic::agent::statsengine::gcprofiler::profiler","newrelic::agent::statsengine::gcprofiler::railsbench","newrelic::agent::statsengine::gcprofiler::rubinius","newrelic::agent::statsengine::gcprofiler::ruby19","newrelic::agent::statsengine::metricstats","newrelic::agent::statsengine::metricstats::harvest","newrelic::agent::statsengine::metricstats::synchronizedhash","newrelic::agent::statsengine::samplers","newrelic::agent::statsengine::scopestackelement","newrelic::agent::statsengine::transactions","newrelic::agent::transactioninfo","newrelic::agent::transactionsamplebuilder","newrelic::agent::transactionsampler","newrelic::agent::transactionsqldata","newrelic::agent::workerloop","newrelic::apdexstats","newrelic::basicstats","newrelic::chainedcall","newrelic::collectionhelper","newrelic::command","newrelic::command::commandfailure","newrelic::command::deployments","newrelic::command::install","newrelic::control","newrelic::control::classmethods","newrelic::control::configuration","newrelic::control::frameworks","newrelic::control::frameworks::external","newrelic::control::frameworks::merb","newrelic::control::frameworks::rails","newrelic::control::frameworks::rails3","newrelic::control::frameworks::ruby","newrelic::control::frameworks::sinatra","newrelic::control::instancemethods","newrelic::control::instrumentation","newrelic::control::loggingmethods","newrelic::control::profiling","newrelic::control::servermethods","newrelic::dataserialization","newrelic::dataserialization::classmethods","newrelic::delayedjobinjection","newrelic::instrumentation","newrelic::instrumentation::actsassolrinstrumentation","newrelic::instrumentation::actsassolrinstrumentation::parsermethodsinstrumentation","newrelic::languagesupport","newrelic::languagesupport::control","newrelic::languagesupport::dataserialization","newrelic::languagesupport::synchronizedhash","newrelic::localenvironment","newrelic::merbbootloader","newrelic::methodtracestats","newrelic::metricdata","newrelic::metricspec","newrelic::metrics","newrelic::noticederror","newrelic::rack","newrelic::rack::browsermonitoring","newrelic::rack::developermode","newrelic::railtie","newrelic::scopedmethodtracestats","newrelic::stats","newrelic::statsbase","newrelic::transactionanalysis","newrelic::transactionanalysis::segmentsummary","newrelic::transactionsample","newrelic::transactionsample::compositesegment","newrelic::transactionsample::fakesegment","newrelic::transactionsample::segment","newrelic::transactionsample::summarysegment","newrelic::urlrule","newrelic::urlrule::ruleset","newrelic::versionnumber","object","newrelic::transactionanalysis::segmentsummary#<<()","newrelic::metricspec#<=>()","newrelic::versionnumber#<=>()","newrelic::metricspec#==()","newrelic::control::configuration#[]()","newrelic::transactionsample::segment#[]()","newrelic::agent::statsengine::metricstats::synchronizedhash#[]=()","newrelic::control::configuration#[]=()","newrelic::transactionsample::segment#[]=()","newrelic::rack::developermode#_call()","newrelic::agent#abort_transaction!()","newrelic::agent::instrumentation::metricframe#abort_transaction!()","newrelic::agent::instrumentation::metricframe::abort_transaction!()","newrelic::stats#absent?()","newrelic::transactionsample::segment#add_called_segment()","newrelic::agent#add_custom_parameters()","newrelic::agent::instrumentation::metricframe::add_custom_parameters()","newrelic::agent::instrumentation::metricframe#add_custom_parameters()","newrelic::agent::transactionsampler#add_force_persist_to()","newrelic::agent::statsengine::samplers#add_harvest_sampler()","newrelic::agent#add_instrumentation()","newrelic::control::instrumentation#add_instrumentation()","newrelic::agent::methodtracer::classmethods#add_method_tracer()","newrelic::agent::transactionsampler#add_random_sample_to()","newrelic::agent#add_request_parameters()","newrelic::agent::statsengine::samplers#add_sampler()","newrelic::agent::transactionsampler#add_samples_to()","newrelic::transactionsample::summarysegment#add_segments()","newrelic::agent::errorcollector::noticeerror#add_to_error_queue()","newrelic::agent::instrumentation::controllerinstrumentation::classmethods#add_transaction_tracer()","newrelic::agent#after_fork()","newrelic::agent::agent::instancemethods#after_fork()","newrelic::agent::shimagent#after_fork()","object#after_fork()","object#after_fork_with_newrelic()","newrelic::agent::instrumentation::metricframe::agent()","newrelic::agent::sqltrace#agent_config()","newrelic::control::instancemethods#agent_enabled?()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#agent_instance()","newrelic::agent::sqltrace#aggregate()","newrelic::agent::agent::instancemethods::start#already_started?()","newrelic::agent::methodtracer::classmethods::addmethodtracer#any_unrecognized_keys?()","newrelic::agent::agent::instancemethods::connect#apdex_f()","newrelic::agent::agent::instancemethods::connect#apdex_f_threshold?()","newrelic::stats#apdex_score()","newrelic::control::configuration#apdex_t()","newrelic::control::servermethods#api_server()","newrelic::control::instancemethods#app()","newrelic::control::configuration#app_names()","newrelic::agent::transactionsampler#append_backtrace()","newrelic::control::frameworks::rails#append_environment_info()","newrelic::control::frameworks::rails3#append_environment_info()","newrelic::control::instancemethods#append_environment_info()","newrelic::localenvironment#append_environment_value()","newrelic::localenvironment#append_gem_list()","newrelic::agent::transactionsampler#append_new_message()","newrelic::localenvironment#append_plugin_list()","newrelic::urlrule#apply()","newrelic::stats#as_percentage()","newrelic::stats#as_percentage_of()","newrelic::agent::methodtracer::classmethods::addmethodtracer#assemble_code_header()","newrelic::rack::browsermonitoring#autoinstrument_source()","newrelic::stats#average_call_time()","newrelic::stats#average_exclusive_time()","newrelic::transactionanalysis::segmentsummary#average_exclusive_time()","newrelic::stats#average_response_time()","newrelic::transactionanalysis::segmentsummary#average_time()","newrelic::stats#average_value()","newrelic::statsbase#begin_time()","newrelic::statsbase#begin_time=()","newrelic::transactionanalysis#breakdown_data()","newrelic::control::configuration#browser_monitoring_auto_instrument?()","newrelic::agent#browser_timing_footer()","newrelic::agent::browsermonitoring#browser_timing_footer()","newrelic::agent::shimagent#browser_timing_footer()","newrelic::agent#browser_timing_header()","newrelic::agent::browsermonitoring#browser_timing_header()","newrelic::agent::shimagent#browser_timing_header()","newrelic::agent::beaconconfiguration#build_browser_timing_header()","newrelic::agent::beaconconfiguration#build_load_file_js()","newrelic::agent::transactionsampler#builder()","newrelic::control::instancemethods#bundler_gem_list()","newrelic::agent::busycalculator#busy_count()","newrelic::chainedcall#call()","newrelic::rack::browsermonitoring#call()","newrelic::rack::developermode#call()","newrelic::agent::statsengine::gcprofiler::railsbench#call_count()","newrelic::agent::statsengine::gcprofiler::rubinius#call_count()","newrelic::agent::statsengine::gcprofiler::ruby19#call_count()","newrelic::agent::statsengine::gcprofiler::railsbench#call_time()","newrelic::agent::statsengine::gcprofiler::rubinius#call_time()","newrelic::agent::statsengine::gcprofiler::ruby19#call_time()","newrelic::agent::instrumentation::rack#call_with_newrelic()","newrelic::transactionsample::segment#called_segments()","newrelic::transactionsample::segment#called_segments=()","newrelic::stats#calls_per_minute()","newrelic::agent::samplers::memorysampler::base#can_run?()","newrelic::agent::statsengine::gcprofiler::capture()","newrelic::agent::statsengine::gcprofiler::profiler#capture()","newrelic::control::configuration#capture_params()","newrelic::agent::transactionsampler#capture_segment_trace()","newrelic::agent::agent::instancemethods::startworkerthread#catch_errors()","newrelic::control::servermethods#cert_file_path()","newrelic::agent::agent::instancemethods::start#check_config_and_start_agent()","newrelic::agent::methodtracer::classmethods::addmethodtracer#check_for_illegal_keys!()","newrelic::agent::methodtracer::classmethods::addmethodtracer#check_for_push_scope_and_metric()","newrelic::agent::instrumentation::metricframe::check_server_connection=()","newrelic::agent::agent::instancemethods::startworkerthread#check_sql_sampler_status()","newrelic::agent::agent::instancemethods::startworkerthread#check_transaction_sampler_status()","newrelic::stats#checked_calculation()","newrelic::agent::transactionsampler#clamp_number_tts()","newrelic::agent::statsengine::metricstats::synchronizedhash#clear()","newrelic::agent::transactioninfo::clear()","newrelic::agent::transactionsampler#clear_builder()","newrelic::agent::statsengine::metricstats#clear_stats()","newrelic::agent::instrumentation::metricframe::pop#clear_thread_metric_frame!()","newrelic::agent::sqlsampler#clear_transaction_data()","newrelic::agent::database#close_connections()","newrelic::agent::database::connectionmanager#close_connections()","newrelic::agent::methodtracer::classmethods::addmethodtracer#code_to_eval()","newrelic::command::deployments::command()","newrelic::command::install::command()","newrelic::agent::database#config()","newrelic::agent::sqlsampler#config()","newrelic::agent::transactionsampler#config()","newrelic::agent::database#config=()","newrelic::control::frameworks::ruby#config_file()","newrelic::control::instancemethods#config_file()","newrelic::agent::agent::instancemethods::connect#config_transaction_tracer()","newrelic::agent::sqlsampler#configure!()","newrelic::agent::transactionsampler#configure!()","newrelic::agent::agent::instancemethods::connect#configure_error_collector!()","newrelic::agent::agent::instancemethods::connect#configure_transaction_tracer!()","newrelic::agent::agent::instancemethods::start#connect_in_foreground()","newrelic::agent::agent::instancemethods::connect#connect_settings()","newrelic::agent::agent::instancemethods::connect#connect_to_server()","newrelic::agent::agent::instancemethods#connected?()","newrelic::command::install#content()","newrelic::agent::errorcollector#control()","newrelic::control::servermethods#convert_to_ip_address()","newrelic::agent::agent::instancemethods::start#correct_license_length()","newrelic::transactionsample#count_segments()","newrelic::transactionsample::segment#count_segments()","newrelic::agent::instrumentation::metricframe::pop#cpu_burn()","newrelic::agent::agent::instancemethods::startworkerthread#create_and_run_worker_loop()","newrelic::transactionsample#create_segment()","newrelic::agent::sqlsampler#create_transaction_data()","newrelic::agent::instrumentation::metricframe::current()","newrelic::agent::instrumentation::metricframe#current_metric()","newrelic::agent::transactionsampler#current_sample_id()","newrelic::agent::instrumentation::metricframe::pop#current_stack_metric()","newrelic::agent::instrumentation::metricframe#custom_parameters()","newrelic::agent::instrumentation::metricframe::custom_parameters()","newrelic::agent::errorcollector::noticeerror#custom_params_from_opts()","newrelic::agent::instrumentation::metricframe::database_metric_name()","newrelic::transactionanalysis#database_time()","newrelic::agent::methodtracer::classmethods::addmethodtracer#default_metric_name_code()","newrelic::agent::database::obfuscator#default_sql_obfuscator()","newrelic::agent::agent::instancemethods::startworkerthread#deferred_work!()","newrelic::agent::statsengine::metricstats::synchronizedhash#delete()","newrelic::agent::statsengine::metricstats::synchronizedhash#delete_if()","newrelic::transactionsample::compositesegment#detail_segments=()","newrelic::control::configuration#developer_mode?()","newrelic::agent::sqlsampler#disable()","newrelic::agent::transactionsampler#disable()","newrelic::agent#disable_all_tracing()","newrelic::control::configuration#disable_backtrace_cleanup?()","newrelic::control::configuration#disable_serialization=()","newrelic::control::configuration#disable_serialization?()","newrelic::agent#disable_sql_recording()","newrelic::agent#disable_transaction_tracing()","newrelic::agent::agent::instancemethods::start#disabled?()","newrelic::agent::errorcollector::noticeerror#disabled?()","newrelic::agent::agent::instancemethods::connect#disconnect()","newrelic::control::configuration#dispatcher()","newrelic::agent::busycalculator#dispatcher_finish()","newrelic::control::configuration#dispatcher_instance_id()","newrelic::localenvironment#dispatcher_instance_id()","newrelic::agent::busycalculator#dispatcher_start()","newrelic::agent::instrumentation::controllerinstrumentation#do_not_trace?()","newrelic::agent::transactioninfo#duration()","newrelic::stats#duration()","newrelic::transactionsample#duration()","newrelic::transactionsample::segment#duration()","newrelic::languagesupport::synchronizedhash#each()","newrelic::transactionsample#each_segment()","newrelic::transactionsample::segment#each_segment()","newrelic::transactionsample#each_segment_with_nest_tracking()","newrelic::transactionsample::segment#each_segment_with_nest_tracking()","newrelic::agent::sqlsampler#enable()","newrelic::agent::transactionsampler#enable()","newrelic::agent::agent::instancemethods::connect#enable_random_samples!()","newrelic::agent::sqlsampler#enabled?()","newrelic::agent::statsengine::gcprofiler::railsbench::enabled?()","newrelic::agent::statsengine::gcprofiler::rubinius::enabled?()","newrelic::agent::statsengine::gcprofiler::ruby19::enabled?()","newrelic::agent::transactionsampler#enabled?()","newrelic::statsbase#end_time()","newrelic::statsbase#end_time=()","newrelic::transactionsample::segment#end_trace()","newrelic::agent::agent::instancemethods#end_transaction()","newrelic::agent::statsengine::transactions#end_transaction()","newrelic::agent::instrumentation::metricframe::pop#end_transaction!()","newrelic::transactionsample#ensure_segment_count_set()","newrelic::control::frameworks::merb#env()","newrelic::control::frameworks::rails#env()","newrelic::control::frameworks::rails3#env()","newrelic::control::frameworks::ruby#env()","newrelic::control::frameworks::sinatra#env()","newrelic::agent::agent::instancemethods::connect#environment_for_connect()","newrelic::metricdata#eql?()","newrelic::metricspec#eql?()","newrelic::versionnumber#eql?()","newrelic::command#err()","newrelic::agent::errorcollector::noticeerror#error_is_ignored?()","newrelic::agent::errorcollector::noticeerror#error_params_from_options()","newrelic::agent::errorcollector::noticeerror#exception_info()","newrelic::transactionsample::segment#exclusive_duration()","newrelic::stats#exclusive_time_percentage()","newrelic::transactionanalysis::segmentsummary#exclusive_time_percentage()","newrelic::stats#expand_min_max_to()","newrelic::agent::slowsql#explain()","newrelic::agent::database#explain_sql()","newrelic::transactionsample::segment#explain_sql()","newrelic::agent::database#explain_statement()","newrelic::agent::errorcollector::noticeerror#extract_source()","newrelic::agent::errorcollector::noticeerror#extract_stack_trace()","newrelic::control::configuration#fetch()","newrelic::agent::errorcollector::noticeerror#fetch_from_options()","newrelic::agent::errorcollector::noticeerror#filtered_by_error_filter?()","newrelic::agent::errorcollector::noticeerror#filtered_error?()","newrelic::localenvironment#find_class_in_object_space()","newrelic::control::loggingmethods#find_or_create_file_path()","newrelic::transactionsample#find_segment()","newrelic::transactionsample::segment#find_segment()","newrelic::agent::beaconconfiguration#finish_command()","newrelic::agent::agent::instancemethods::connect#finish_setup()","newrelic::agent::transactionsamplebuilder#finish_trace()","newrelic::agent::transactioninfo#force_persist_sample?()","newrelic::stats#fraction_of()","newrelic::control::instancemethods#framework()","newrelic::agent::transactionsamplebuilder#freeze()","newrelic::statsbase#freeze()","newrelic::localenvironment#gather_ar_adapter_info()","newrelic::localenvironment#gather_architecture_info()","newrelic::localenvironment#gather_cpu_info()","newrelic::localenvironment#gather_db_info()","newrelic::localenvironment#gather_dm_adapter_info()","newrelic::localenvironment#gather_environment_info()","newrelic::localenvironment#gather_jruby_info()","newrelic::localenvironment#gather_os_info()","newrelic::localenvironment#gather_revision_info()","newrelic::localenvironment#gather_ruby_info()","newrelic::localenvironment#gather_system_info()","newrelic::agent::transactioninfo::get()","newrelic::stats#get_apdex()","newrelic::agent::database#get_connection()","newrelic::agent::database::connectionmanager#get_connection()","newrelic::agent::statsengine::metricstats#get_custom_stats()","newrelic::agent::samplers::memorysampler::javaheapsampler#get_memory()","newrelic::agent::samplers::memorysampler::procstatus#get_memory()","newrelic::agent::samplers::memorysampler::shellps#get_memory()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#get_metric_stats()","newrelic::agent::agent::instancemethods::connect#get_retry_period()","newrelic::agent::samplers::memorysampler::base#get_sample()","newrelic::agent#get_stats()","newrelic::agent::statsengine::metricstats#get_stats()","newrelic::agent#get_stats_no_scope()","newrelic::agent::statsengine::metricstats#get_stats_no_scope()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#get_stats_scoped()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#get_stats_unscoped()","newrelic::agent::transactioninfo#guid()","newrelic::agent::transactioninfo#guid=()","newrelic::agent::instrumentation::metricframe::pop#handle_empty_path_stack()","newrelic::agent::database#handle_exception_in_explain()","newrelic::agent::agent::instancemethods::startworkerthread#handle_force_disconnect()","newrelic::agent::agent::instancemethods::startworkerthread#handle_force_restart()","newrelic::agent::agent::instancemethods::connect#handle_license_error()","newrelic::agent::agent::instancemethods::startworkerthread#handle_other_error()","newrelic::agent::agent::instancemethods::startworkerthread#handle_server_connection_problem()","newrelic::agent::sqlsampler#harvest()","newrelic::agent::transactionsampler#harvest()","newrelic::agent::busycalculator#harvest_busy()","newrelic::agent::errorcollector#harvest_errors()","newrelic::agent::sqlsampler#harvest_slow_sql()","newrelic::agent::statsengine::metricstats#harvest_timeslice_data()","newrelic::agent::agent::instancemethods::start#has_correct_license_key?()","newrelic::agent::agent::instancemethods::start#has_license_key?()","newrelic::metricdata#hash()","newrelic::metricspec#hash()","newrelic::versionnumber#hash()","newrelic::control::servermethods#http_connection()","newrelic::agent::errorcollector#ignore()","newrelic::agent::instrumentation::controllerinstrumentation#ignore_apdex?()","newrelic::agent#ignore_error_filter()","newrelic::agent::errorcollector#ignore_error_filter()","newrelic::agent::transactionsamplebuilder#ignore_transaction()","newrelic::agent::transactionsampler#ignore_transaction()","newrelic::agent::transactionsamplebuilder#ignored?()","newrelic::agent::transactioninfo#include_guid?()","newrelic::agent::instrumentation::activerecordinstrumentation::included()","newrelic::agent::instrumentation::datamapperinstrumentation::included()","newrelic::languagesupport::control::included()","newrelic::languagesupport::dataserialization::included()","newrelic::languagesupport::synchronizedhash::included()","newrelic::methodtracestats#increment_count()","newrelic::agent::errorcollector::noticeerror#increment_error_count!()","newrelic::command#info()","newrelic::agent::sampler::inherited()","newrelic::command::inherited()","newrelic::agent::statsengine::gcprofiler::init()","newrelic::control::frameworks::external#init_config()","newrelic::control::frameworks::merb#init_config()","newrelic::control::frameworks::rails#init_config()","newrelic::control::frameworks::ruby#init_config()","newrelic::control::frameworks::sinatra#init_config()","newrelic::control::instancemethods#init_plugin()","object#initialize()","object#initialize_with_new_relic()","object#initialize_without_new_relic()","newrelic::methodtracestats#inspect()","newrelic::metricdata#inspect()","newrelic::metricspec#inspect()","newrelic::control::frameworks::rails#install_browser_monitoring()","newrelic::control::frameworks::rails#install_developer_mode()","newrelic::agent::agent::instancemethods::start#install_exit_handler()","newrelic::control::instrumentation#install_instrumentation()","newrelic::control::frameworks::rails#install_shim()","newrelic::control::instrumentation#install_shim()","newrelic::agent::agent::classmethods#instance()","newrelic::agent::shimagent::instance()","newrelic::control::classmethods#instance()","newrelic::agent::instrumentation::memcache#instrument_methods()","newrelic::agent#is_execution_traced?()","newrelic::stats#is_reset?()","newrelic::agent::database#is_select?()","newrelic::agent#is_sql_recorded?()","newrelic::agent#is_transaction_traced?()","newrelic::agent::instrumentation::metricframe#is_web_transaction?()","newrelic::agent::beaconconfiguration#javascript_header()","newrelic::agent::instrumentation::metricframe::pop#jruby_cpu_burn()","newrelic::agent::workerloop#keep_running()","newrelic::agent::beaconconfiguration#license_bytes()","newrelic::control::configuration#license_key()","newrelic::languagesupport::dataserialization::load()","newrelic::agent#load_data()","newrelic::control::classmethods#load_framework_class()","newrelic::control::instrumentation#load_instrumentation_files()","newrelic::control::instancemethods#load_newrelic_yml()","newrelic::languagesupport::control#load_newrelic_yml()","newrelic::control::instrumentation#load_samplers()","newrelic::control::classmethods#load_test_framework()","newrelic::agent::samplers::delayedjoblocksampler#local_env()","newrelic::control::classmethods#local_env()","newrelic::agent::workerloop#lock()","newrelic::agent::samplers::delayedjoblocksampler#locked_jobs()","newrelic::agent::agent::instancemethods#log()","newrelic::agent::statsengine#log()","newrelic::agent::workerloop#log()","newrelic::control::loggingmethods#log()","newrelic::control::frameworks::rails#log!()","newrelic::control::frameworks::rails3#log!()","newrelic::control::loggingmethods#log!()","newrelic::agent::agent::instancemethods::start#log_app_names()","newrelic::agent::agent::instancemethods::connect#log_connection!()","newrelic::agent::agent::instancemethods::start#log_dispatcher()","newrelic::agent::agent::instancemethods::connect#log_error()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#log_errors()","newrelic::control#log_file_name()","newrelic::control::configuration#log_file_path()","newrelic::agent::agent::instancemethods::start#log_if()","newrelic::control::loggingmethods#log_path()","newrelic::agent::agent::instancemethods::connect#log_seed_token()","newrelic::agent::agent::instancemethods::connect#log_sql_transmission_warning?()","newrelic::control#log_to_stdout?()","newrelic::agent::instrumentation::metricframe::pop#log_underflow()","newrelic::agent::agent::instancemethods::start#log_unless()","newrelic::agent::agent::instancemethods::start#log_version_and_pid()","newrelic::agent::instrumentation::activerecordinstrumentation#log_with_newrelic_instrumentation()","newrelic::agent::instrumentation::datamapperinstrumentation#log_with_newrelic_instrumentation()","newrelic::agent::agent::instancemethods::startworkerthread#log_worker_loop_start()","newrelic::agent#logger()","newrelic::control::frameworks::rails#logger()","newrelic::control::frameworks::rails3#logger()","newrelic::agent::statsengine::metricstats#lookup_stats()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#main_stat()","newrelic::versionnumber#major_version()","newrelic::agent#manual_start()","newrelic::agent::instrumentation::memcache#memcache_key_snippet()","newrelic::agent::sqlsampler#merge()","newrelic::stats#merge()","newrelic::stats#merge!()","newrelic::stats#merge_attributes()","newrelic::agent::statsengine::metricstats::harvest#merge_data()","newrelic::agent::agent::instancemethods#merge_data_from()","newrelic::agent::shimagent#merge_data_from()","newrelic::control::configuration#merge_defaults()","newrelic::control::configuration#merge_options()","newrelic::control::configuration#merge_server_side_config()","newrelic::agent::methodtracer::classmethods::addmethodtracer#method_with_push_scope()","newrelic::agent::methodtracer::classmethods::addmethodtracer#method_without_push_scope()","newrelic::agent::instrumentation::metricframe#metric_name()","newrelic::metricdata#metric_spec=()","newrelic::agent::statsengine::metricstats#metrics()","newrelic::stats#midpoint()","newrelic::stats#min_time_less?()","newrelic::versionnumber#minor_version()","newrelic::localenvironment#mongrel()","newrelic::control::configuration#monitor_mode?()","newrelic::agent::agent::instancemethods::start#monitoring?()","newrelic::control::configuration#multi_threaded?()","newrelic::stats#multiply_by()","newrelic::agent::sqltrace#need_to_explain?()","newrelic::agent::sqltrace#need_to_obfuscate?()","newrelic::agent::agent::new()","newrelic::agent::beaconconfiguration::new()","newrelic::agent::browsermonitoring::dummymetricframe::new()","newrelic::agent::database::obfuscator::new()","newrelic::agent::errorcollector::new()","newrelic::agent::instrumentation::metricframe::new()","newrelic::agent::sampler::new()","newrelic::agent::samplers::cpusampler::new()","newrelic::agent::samplers::delayedjoblocksampler::new()","newrelic::agent::samplers::memorysampler::new()","newrelic::agent::samplers::memorysampler::shellps::new()","newrelic::agent::samplers::objectsampler::new()","newrelic::agent::shimagent::new()","newrelic::agent::slowsql::new()","newrelic::agent::sqlsampler::new()","newrelic::agent::sqltrace::new()","newrelic::agent::statsengine::new()","newrelic::agent::statsengine::gcprofiler::profiler::new()","newrelic::agent::statsengine::metricstats::synchronizedhash::new()","newrelic::agent::statsengine::scopestackelement::new()","newrelic::agent::transactioninfo::new()","newrelic::agent::transactionsamplebuilder::new()","newrelic::agent::transactionsampler::new()","newrelic::agent::transactionsqldata::new()","newrelic::agent::workerloop::new()","newrelic::chainedcall::new()","newrelic::command::new()","newrelic::command::commandfailure::new()","newrelic::command::deployments::new()","newrelic::command::install::new()","newrelic::control::instancemethods::new()","newrelic::localenvironment::new()","newrelic::metricdata::new()","newrelic::metricspec::new()","newrelic::noticederror::new()","newrelic::rack::browsermonitoring::new()","newrelic::rack::developermode::new()","newrelic::scopedmethodtracestats::new()","newrelic::statsbase::new()","newrelic::transactionanalysis::segmentsummary::new()","newrelic::transactionsample::new()","newrelic::transactionsample::compositesegment::new()","newrelic::transactionsample::segment::new()","newrelic::transactionsample::summarysegment::new()","newrelic::versionnumber::new()","newrelic::control::classmethods#new_instance()","newrelic::agent::instrumentation::controllerinstrumentation::classmethods#newrelic_ignore()","newrelic::agent::instrumentation::controllerinstrumentation::classmethods#newrelic_ignore_apdex()","newrelic::agent::methodtracer::classmethods::addmethodtracer#newrelic_method_exists?()","newrelic::agent::instrumentation::rails3::actioncontroller#newrelic_metric_path()","object#newrelic_metric_path()","newrelic::agent::instrumentation::rails3::errors#newrelic_notice_error()","object#newrelic_notice_error()","newrelic::agent::instrumentation::controllerinstrumentation#newrelic_request_headers()","newrelic::agent::instrumentation::rack#newrelic_request_headers()","newrelic::agent::instrumentation::controllerinstrumentation#newrelic_response_code()","newrelic::control::classmethods#newrelic_root()","newrelic::control::instancemethods#newrelic_root()","newrelic::agent::instrumentation::metricframe::pop#normal_cpu_burn()","newrelic::agent::slowsql#normalize()","newrelic::collectionhelper#normalize_params()","newrelic::agent::errorcollector::noticeerror#normalized_request_and_custom_params()","newrelic::agent#notice_error()","newrelic::agent::errorcollector#notice_error()","newrelic::agent::instrumentation::metricframe::notice_error()","newrelic::agent::sqlsampler#notice_first_scope_push()","newrelic::agent::transactionsampler#notice_first_scope_push()","newrelic::agent::transactionsampler#notice_nosql()","newrelic::agent::transactionsampler#notice_pop_scope()","newrelic::agent::transactionsampler#notice_profile()","newrelic::agent::transactionsampler#notice_push_scope()","newrelic::agent::instrumentation::metricframe::pop#notice_scope_empty()","newrelic::agent::sqlsampler#notice_scope_empty()","newrelic::agent::transactionsampler#notice_scope_empty()","newrelic::agent::sqlsampler#notice_sql()","newrelic::agent::transactionsampler#notice_sql()","newrelic::agent::sqlsampler#notice_transaction()","newrelic::agent::transactionsampler#notice_transaction()","newrelic::agent::transactionsampler#notice_transaction_cpu_time()","newrelic::agent::agent::instancemethods::start#notify_log_file_location()","newrelic::agent::instrumentation::metricframe::pop#notify_transaction_sampler()","newrelic::agent::slowsql#obfuscate()","newrelic::agent::database#obfuscate_sql()","newrelic::transactionsample::segment#obfuscated_sql()","newrelic::transactionsample#omit_segments_with()","newrelic::metricdata#original_spec()","newrelic::agent::errorcollector::noticeerror#over_queue_limit?()","newrelic::transactionsample::segment#params()","newrelic::transactionsample#params=()","newrelic::transactionsample::segment#params=()","newrelic::transactionsample::segment#parent_segment=()","newrelic::agent::instrumentation::queuetime#parse_frontend_headers()","newrelic::instrumentation::actsassolrinstrumentation::parsermethodsinstrumentation#parse_query_with_newrelic()","newrelic::agent::instrumentation::metricframe#path()","newrelic::transactionsample#path_string()","newrelic::transactionsample::segment#path_string()","newrelic::agent::statsengine::transactions#peek_scope()","newrelic::agent::instrumentation::controllerinstrumentation#perform_action_with_newrelic_trace()","newrelic::dataserialization::classmethods#pid_too_old?()","newrelic::agent::samplers::memorysampler::platform()","newrelic::agent::samplers::memorysampler#platform()","newrelic::agent::sampler#poll()","newrelic::agent::samplers::cpusampler#poll()","newrelic::agent::samplers::delayedjoblocksampler#poll()","newrelic::agent::samplers::memorysampler#poll()","newrelic::agent::samplers::objectsampler#poll()","newrelic::agent::instrumentation::metricframe#pop()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#pop_flag!()","newrelic::agent::statsengine::transactions#pop_scope()","newrelic::agent::agent::instancemethods#pop_trace_execution_flag()","newrelic::agent::shimagent#pop_trace_execution_flag()","newrelic::control::configuration#post_size_limit()","newrelic::agent::sqltrace#prepare_to_send()","newrelic::transactionsample#prepare_to_send()","newrelic::agent::samplers::memorysampler::procstatus#proc_status_file()","newrelic::agent::instrumentation::rails3::actioncontroller#process_action()","newrelic::agent::database#process_resultset()","newrelic::control::profiling#profiling=()","newrelic::control::profiling#profiling?()","newrelic::control::profiling#profiling_available?()","newrelic::control::servermethods#proxy_server()","newrelic::agent::instrumentation::metricframe#push()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#push_flag!()","newrelic::agent::statsengine::transactions#push_scope()","newrelic::agent::agent::instancemethods#push_trace_execution_flag()","newrelic::agent::shimagent#push_trace_execution_flag()","newrelic::agent::agent::instancemethods::connect#query_server_for_configuration()","newrelic::agent::browsermonitoring::dummymetricframe#queue_time()","newrelic::agent::instrumentation::metricframe#queue_time()","newrelic::control::frameworks::rails#rails_gem_list()","newrelic::control::frameworks::rails#rails_vendor_root()","newrelic::control::frameworks::rails#rails_version()","newrelic::dataserialization::classmethods#read_and_write_to_file()","newrelic::agent::instrumentation::metricframe::record_apdex()","newrelic::agent::instrumentation::metricframe#record_apdex()","newrelic::apdexstats#record_apdex_f()","newrelic::apdexstats#record_apdex_s()","newrelic::apdexstats#record_apdex_t()","newrelic::methodtracestats#record_data_point()","newrelic::agent::statsengine::gcprofiler::profiler#record_gc_metric()","newrelic::agent::instrumentation::metricframe::pop#record_jruby_cpu_burn()","newrelic::methodtracestats#record_multiple_data_points()","newrelic::scopedmethodtracestats#record_multiple_data_points()","newrelic::agent#record_transaction()","newrelic::agent::agent::instancemethods#record_transaction()","newrelic::agent::instrumentation::metricframe::pop#record_transaction_cpu()","newrelic::agent::instrumentation::metricframe#recorded_metrics()","newrelic::agent::instrumentation::metricframe::recording_web_transaction?()","newrelic::agent::instrumentation::metricframe#recording_web_transaction?()","newrelic::agent::instrumentation::metricframe::referer()","newrelic::agent::instrumentation::metricframe#referer()","newrelic::agent::instrumentation::metricframe::referer_from_request()","newrelic::control::configuration#remove_server_controlled_configs()","newrelic::agent::statsengine::transactions#remove_transaction_sampler()","actionview::partials::partialrenderer#render_collection()","actionview::partials::partialrenderer#render_partial()","newrelic::transactionanalysis#render_time()","object#request()","newrelic::agent::errorcollector::noticeerror#request_params_from_opts()","object#request_with_newrelic_trace()","object#request_without_newrelic_trace()","newrelic::stats#requests_per_minute()","object#rescue_action_with_newrelic_trace()","newrelic::agent::busycalculator#reset()","newrelic::agent::database::obfuscator#reset()","newrelic::agent::statsengine::gcprofiler::profiler#reset()","newrelic::agent::statsengine::gcprofiler::ruby19#reset()","newrelic::stats#reset()","newrelic::agent::sqlsampler#reset!()","newrelic::agent::transactionsampler#reset!()","newrelic::agent#reset_stats()","newrelic::agent::agent::instancemethods#reset_stats()","newrelic::agent::statsengine::metricstats#reset_stats()","newrelic::control::servermethods#resolve_ip_address()","newrelic::control::frameworks::merb#root()","newrelic::control::frameworks::rails#root()","newrelic::control::frameworks::rails3#root()","newrelic::control::frameworks::ruby#root()","newrelic::control::instancemethods#root()","newrelic::agent::instrumentation::sinatra#route_eval_with_newrelic()","newrelic::agent::workerloop#run()","newrelic::command::run()","newrelic::command::deployments#run()","newrelic::command::install#run()","newrelic::merbbootloader::run()","newrelic::agent::workerloop#run_task()","newrelic::agent::transactionsamplebuilder#sample_id()","newrelic::agent::sampler::sampler_classes()","newrelic::agent::transactionsampler#sampling_rate=()","newrelic::agent#save_data()","newrelic::agent::transactionsamplebuilder#scope_depth()","newrelic::agent::transactionsampler#scope_depth()","newrelic::agent::statsengine::transactions#scope_name()","newrelic::agent::statsengine::transactions#scope_name=()","newrelic::agent::statsengine::gcprofiler::profiler#scope_stack()","newrelic::control::configuration#send_data_on_exit()","newrelic::agent::errorcollector::noticeerror#sense_method()","newrelic::agent::agent::instancemethods#serialize()","newrelic::agent::shimagent#serialize()","newrelic::control::servermethods#server()","newrelic::control::servermethods#server_from_host()","newrelic::agent::transactioninfo::set()","newrelic::agent::agent::instancemethods::connect#set_collector_host!()","newrelic::agent::methodtracer::classmethods::addmethodtracer#set_deduct_call_time_based_on_metric()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#set_if_nil()","newrelic::control::loggingmethods#set_log_format!()","newrelic::control::loggingmethods#set_log_level!()","newrelic::agent::instrumentation::metricframe::pop#set_new_scope!()","newrelic::agent::sqltrace#set_primary()","newrelic::agent::transactionsamplebuilder#set_profile()","newrelic::agent::agent::instancemethods#set_record_sql()","newrelic::agent::agent::instancemethods#set_record_tt()","newrelic::agent#set_sql_obfuscator()","newrelic::agent::database#set_sql_obfuscator()","newrelic::agent::database::obfuscator#set_sql_obfuscator()","newrelic::agent::agent::instancemethods::connect#set_sql_recording!()","newrelic::agent::transactionsamplebuilder#set_transaction_cpu_time()","newrelic::agent::transactionsamplebuilder#set_transaction_info()","newrelic::agent::transactionsqldata#set_transaction_info()","newrelic::agent#set_user_attributes()","newrelic::agent::instrumentation::metricframe#set_user_attributes()","newrelic::agent::instrumentation::metricframe::set_user_attributes()","newrelic::control::configuration#settings()","newrelic::control::loggingmethods#setup_log()","newrelic::agent::errorcollector::noticeerror#should_exit_notice_error?()","newrelic::rack::browsermonitoring#should_instrument?()","newrelic::agent::agent::instancemethods::connect#should_keep_retrying?()","newrelic::control::loggingmethods#should_log?()","newrelic::stats#should_replace_begin_time?()","newrelic::stats#should_replace_end_time?()","newrelic::agent::agent::instancemethods::connect#should_retry?()","newrelic::dataserialization::classmethods#should_send_data?()","newrelic::agent#shutdown()","newrelic::agent::agent::instancemethods#shutdown()","newrelic::agent::shimagent#shutdown()","newrelic::agent::transactionsampler#slowest_sample?()","newrelic::localenvironment#snapshot()","newrelic::stats#split()","newrelic::transactionanalysis#sql_segments()","newrelic::stats#stack_min_max_from()","newrelic::stats#standard_deviation()","newrelic::agent::agent::instancemethods#start()","newrelic::agent::shimagent#start()","newrelic::control::instancemethods#start_agent()","newrelic::agent::transactionsampler#start_builder()","newrelic::agent::statsengine::samplers#start_sampler_thread()","newrelic::transactionsample#start_time()","newrelic::agent::agent::instancemethods#start_transaction()","newrelic::agent::instrumentation::metricframe#start_transaction()","newrelic::agent::statsengine::transactions#start_transaction()","newrelic::agent::agent::instancemethods#started?()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#stat_engine()","newrelic::agent::samplers::delayedjoblocksampler#stats()","newrelic::agent::samplers::memorysampler#stats()","newrelic::agent::samplers::objectsampler#stats()","newrelic::agent::statsengine::metricstats#stats_hash()","newrelic::agent::workerloop#stop()","newrelic::agent::transactionsampler#store_force_persist()","newrelic::agent::transactionsampler#store_random_sample()","newrelic::agent::transactionsampler#store_sample()","newrelic::agent::transactionsampler#store_sample_for_developer_mode()","newrelic::agent::transactionsampler#store_slowest_sample()","newrelic::dataserialization::classmethods#store_too_large?()","newrelic::dataserialization::classmethods#store_too_old?()","newrelic::collectionhelper#strip_nr_from_backtrace()","newrelic::metricspec#sub()","newrelic::stats#sum_attributes()","newrelic::stats#sum_merge!()","newrelic::stats#summary()","newrelic::agent::sampler::supported_on_this_platform?()","newrelic::agent::samplers::cpusampler::supported_on_this_platform?()","newrelic::agent::samplers::delayedjoblocksampler::supported_on_this_platform?()","newrelic::agent::samplers::memorysampler::supported_on_this_platform?()","newrelic::agent::samplers::objectsampler::supported_on_this_platform?()","newrelic::control::configuration#sync_startup()","newrelic::agent::samplers::cpusampler#system_util_stats()","newrelic::agent::samplers::cpusampler#systemtime_stats()","newrelic::stats#time_percentage()","newrelic::stats#time_str()","newrelic::transactionsample#timestamp()","newrelic::versionnumber#tiny_version()","newrelic::transactionsample::segment#to_debug_str()","newrelic::agent::sqltrace#to_json()","newrelic::metricdata#to_json()","newrelic::metricspec#to_json()","newrelic::statsbase#to_json()","newrelic::transactionsample::segment#to_json()","newrelic::agent::samplers::memorysampler::javaheapsampler#to_s()","newrelic::agent::samplers::memorysampler::procstatus#to_s()","newrelic::agent::samplers::memorysampler::shellps#to_s()","newrelic::localenvironment#to_s()","newrelic::metricdata#to_s()","newrelic::metricspec#to_s()","newrelic::stats#to_s()","newrelic::transactionsample#to_s()","newrelic::transactionsample::segment#to_s()","newrelic::versionnumber#to_s()","newrelic::transactionsample#to_s_compact()","newrelic::transactionsample::segment#to_s_compact()","newrelic::control::frameworks::merb#to_stdout()","newrelic::control::frameworks::rails#to_stdout()","newrelic::control::frameworks::rails3#to_stdout()","newrelic::control::frameworks::ruby#to_stdout()","newrelic::control::loggingmethods#to_stdout()","newrelic::stats#total_call_time_per_minute()","newrelic::transactionanalysis::segmentsummary#total_time_percentage()","newrelic::methodtracestats#trace_call()","newrelic::scopedmethodtracestats#trace_call()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#trace_disabled?()","newrelic::agent::transactionsamplebuilder#trace_entry()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#trace_execution_scoped()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#trace_execution_scoped_footer()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#trace_execution_scoped_header()","newrelic::agent::methodtracer::instancemethods#trace_execution_unscoped()","newrelic::agent::transactionsamplebuilder#trace_exit()","newrelic::agent::methodtracer::instancemethods#trace_method_execution_no_scope()","newrelic::agent::instrumentation::metricframe::pop#traced?()","newrelic::agent::methodtracer::instancemethods::traceexecutionscoped#traced?()","newrelic::agent::methodtracer::classmethods::addmethodtracer#traced_method_exists?()","newrelic::agent::sqlsampler#transaction_data()","newrelic::agent::statsengine::transactions#transaction_sampler=()","newrelic::agent::agent::instancemethods::connect#tried_to_connect?()","newrelic::transactionsample#truncate()","newrelic::transactionsample::segment#truncate()","newrelic::metricspec#truncate!()","newrelic::transactionsample::segment#truncate_each_child()","newrelic::agent::transactionsampler#truncate_message()","newrelic::agent::transactionsampler#truncate_samples()","newrelic::transactionanalysis::segmentsummary#ui_name()","newrelic::agent::methodtracer::classmethods::addmethodtracer#unrecognized_keys()","newrelic::agent::agent::instancemethods#unsent_errors_size()","newrelic::agent::agent::instancemethods#unsent_timeslice_data()","newrelic::agent::agent::instancemethods#unsent_traces_size()","newrelic::agent::instrumentation::metricframe::update_apdex()","newrelic::stats#update_boundaries()","newrelic::dataserialization::classmethods#update_last_sent!()","newrelic::stats#update_totals()","newrelic::agent::instrumentation::metricframe#uri()","newrelic::agent::instrumentation::metricframe::uri_from_request()","newrelic::agent::errorcollector::noticeerror#uri_ref_and_root()","newrelic::agent::sampler::use_harvest_sampler?()","newrelic::control::configuration#use_ssl?()","newrelic::control::configuration#use_textmate?()","newrelic::agent::browsermonitoring::dummymetricframe#user_attributes()","newrelic::agent::instrumentation::metricframe#user_attributes()","newrelic::agent::instrumentation::metricframe::user_attributes()","newrelic::agent::samplers::cpusampler#user_util_stats()","newrelic::agent::samplers::cpusampler#usertime_stats()","newrelic::languagesupport#using_engine?()","newrelic::agent::agent::instancemethods::start#using_forking_dispatcher?()","newrelic::agent::agent::instancemethods::start#using_sinatra?()","newrelic::languagesupport#using_version?()","newrelic::agent::methodtracer::classmethods::addmethodtracer#validate_options()","newrelic::control::configuration#validate_seed()","newrelic::agent::agent::instancemethods::connect#validate_settings()","newrelic::control::configuration#validate_token()","newrelic::control::frameworks::rails3#vendor_root()","newrelic::control::configuration#verify_certificate?()","newrelic::control::frameworks::rails3#version()","newrelic::agent::agent::instancemethods::start#weird_ruby?()","newrelic::agent#with_database_metric_name()","newrelic::agent::instrumentation::metricframe#with_database_metric_name()","newrelic::agent::samplers::delayedjoblocksampler#worker_name()","newrelic::localenvironment#working_jruby?()","","",""],"info":[["ActionController","","ActionController.html","",""],["ActionController::Base","","ActionController/Base.html","",""],["ActionView","","ActionView.html","",""],["ActionView::Base","","ActionView/Base.html","",""],["ActionView::Partials","","ActionView/Partials.html","",""],["ActionView::Partials::PartialRenderer","","ActionView/Partials/PartialRenderer.html","",""],["NewRelic","","NewRelic.html","","<p>NOTE there are multiple implementations of the MemCache client in Ruby,\neach with slightly different …\n"],["NewRelic::Agent","","NewRelic/Agent.html","","<p>Ruby Agent APIs\n<p>This module contains the public API methods for the Ruby Agent.\n<p>For adding custom instrumentation …\n"],["NewRelic::Agent::Agent","","NewRelic/Agent/Agent.html","","<p>The Agent is a singleton that is instantiated when the plugin is activated.\nIt collects performance …\n"],["NewRelic::Agent::Agent::ClassMethods","","NewRelic/Agent/Agent/ClassMethods.html","","<p>contains all the class-level methods for NewRelic::Agent::Agent\n"],["NewRelic::Agent::Agent::InstanceMethods","","NewRelic/Agent/Agent/InstanceMethods.html","","<p>Holds all the methods defined on NewRelic::Agent::Agent instances\n"],["NewRelic::Agent::Agent::InstanceMethods::Connect","","NewRelic/Agent/Agent/InstanceMethods/Connect.html","","<p>This module is an artifact of a refactoring of the connect method - all of\nits methods are used in that …\n"],["NewRelic::Agent::Agent::InstanceMethods::Start","","NewRelic/Agent/Agent/InstanceMethods/Start.html","","<p>Herein lies the corpse of the former ‘start’ method. May it’s\nunmatched flog score rest in pieces.\n"],["NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html","","<p>All of this module used to be contained in the start_worker_thread method -\nthis is an artifact of refactoring …\n"],["NewRelic::Agent::BackgroundLoadingError","","NewRelic/Agent/BackgroundLoadingError.html","",""],["NewRelic::Agent::BeaconConfiguration","","NewRelic/Agent/BeaconConfiguration.html","","<p>This class contains the configuration data for setting up RUM headers and\nfooters - acts as a cache of …\n"],["NewRelic::Agent::BrowserMonitoring","","NewRelic/Agent/BrowserMonitoring.html","","<p>This module contains support for Real User Monitoring - the javascript\ngeneration and configuration\n"],["NewRelic::Agent::BrowserMonitoring::DummyMetricFrame","","NewRelic/Agent/BrowserMonitoring/DummyMetricFrame.html","",""],["NewRelic::Agent::BusyCalculator","","NewRelic/Agent/BusyCalculator.html","","<p>This module supports calculation of actual time spent processing requests\nover the course of one harvest …\n"],["NewRelic::Agent::Database","","NewRelic/Agent/Database.html","",""],["NewRelic::Agent::Database::ConnectionManager","","NewRelic/Agent/Database/ConnectionManager.html","",""],["NewRelic::Agent::Database::Obfuscator","","NewRelic/Agent/Database/Obfuscator.html","",""],["NewRelic::Agent::ErrorCollector","","NewRelic/Agent/ErrorCollector.html","","<p>This class collects errors from the parent application, storing them until\nthey are harvested and transmitted …\n"],["NewRelic::Agent::ErrorCollector::NoticeError","","NewRelic/Agent/ErrorCollector/NoticeError.html","","<p>This module was extracted from the notice_error method - it is internally\ntested and can be refactored …\n"],["NewRelic::Agent::ForceDisconnectException","","NewRelic/Agent/ForceDisconnectException.html","","<p>An exception that forces an agent to stop reporting until its mongrel is\nrestarted.\n"],["NewRelic::Agent::ForceRestartException","","NewRelic/Agent/ForceRestartException.html","","<p>An exception that forces an agent to restart.\n"],["NewRelic::Agent::Instrumentation","","NewRelic/Agent/Instrumentation.html","","<p>stub module that contains instrumentation defined in the instrumentation\ndirectory\n"],["NewRelic::Agent::Instrumentation::ActiveRecordInstrumentation","","NewRelic/Agent/Instrumentation/ActiveRecordInstrumentation.html","",""],["NewRelic::Agent::Instrumentation::ControllerInstrumentation","","NewRelic/Agent/Instrumentation/ControllerInstrumentation.html","","<p>NewRelic instrumentation for controller actions and tasks\n<p>This instrumentation is applied to the action …\n"],["NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods","","NewRelic/Agent/Instrumentation/ControllerInstrumentation/ClassMethods.html","",""],["NewRelic::Agent::Instrumentation::DataMapperInstrumentation","","NewRelic/Agent/Instrumentation/DataMapperInstrumentation.html","",""],["NewRelic::Agent::Instrumentation::Memcache","","NewRelic/Agent/Instrumentation/Memcache.html","",""],["NewRelic::Agent::Instrumentation::MetricFrame","","NewRelic/Agent/Instrumentation/MetricFrame.html","",""],["NewRelic::Agent::Instrumentation::MetricFrame::Pop","","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html","",""],["NewRelic::Agent::Instrumentation::QueueTime","","NewRelic/Agent/Instrumentation/QueueTime.html","",""],["NewRelic::Agent::Instrumentation::Rack","","NewRelic/Agent/Instrumentation/Rack.html","","<p>Instrumentation for Rack\n<p>New Relic will instrument a #call method as if it were a controller action,\ncollecting …\n"],["NewRelic::Agent::Instrumentation::Rails3","","NewRelic/Agent/Instrumentation/Rails3.html","",""],["NewRelic::Agent::Instrumentation::Rails3::ActionController","","NewRelic/Agent/Instrumentation/Rails3/ActionController.html","",""],["NewRelic::Agent::Instrumentation::Rails3::ActionView","","NewRelic/Agent/Instrumentation/Rails3/ActionView.html","",""],["NewRelic::Agent::Instrumentation::Rails3::ActionView::PartialRenderer","","NewRelic/Agent/Instrumentation/Rails3/ActionView/PartialRenderer.html","",""],["NewRelic::Agent::Instrumentation::Rails3::Errors","","NewRelic/Agent/Instrumentation/Rails3/Errors.html","",""],["NewRelic::Agent::Instrumentation::Sinatra","","NewRelic/Agent/Instrumentation/Sinatra.html","","<p>NewRelic instrumentation for Sinatra applications.  Sinatra actions will\nappear in the UI similar to …\n"],["NewRelic::Agent::LicenseException","","NewRelic/Agent/LicenseException.html","","<p>An exception that is thrown by the server if the agent license is invalid.\n"],["NewRelic::Agent::MethodTracer","","NewRelic/Agent/MethodTracer.html","","<p>This module contains class methods added to support installing custom\nmetric tracers and executing for …\n"],["NewRelic::Agent::MethodTracer::ClassMethods","","NewRelic/Agent/MethodTracer/ClassMethods.html","","<p>Defines methods used at the class level, for adding instrumentation\n"],["NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html","","<p>contains methods refactored out of the #add_method_tracer method\n"],["NewRelic::Agent::MethodTracer::InstanceMethods","","NewRelic/Agent/MethodTracer/InstanceMethods.html","","<p>Defines modules used at instrumentation runtime, to do the actual tracing\nof time spent\n"],["NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html","","<p>Refactored out of the previous trace_execution_scoped method, most methods\nin this module relate to code …\n"],["NewRelic::Agent::PostTooBigException","","NewRelic/Agent/PostTooBigException.html","","<p>Used for when a transaction trace or error report has too much data, so we\nreset the queue to clear the …\n"],["NewRelic::Agent::Sampler","","NewRelic/Agent/Sampler.html","",""],["NewRelic::Agent::Sampler::Unsupported","","NewRelic/Agent/Sampler/Unsupported.html","","<p>Exception denotes a sampler is not available and it will not be registered.\n"],["NewRelic::Agent::Samplers","","NewRelic/Agent/Samplers.html","",""],["NewRelic::Agent::Samplers::CpuSampler","","NewRelic/Agent/Samplers/CpuSampler.html","",""],["NewRelic::Agent::Samplers::DelayedJobLockSampler","","NewRelic/Agent/Samplers/DelayedJobLockSampler.html","",""],["NewRelic::Agent::Samplers::MemorySampler","","NewRelic/Agent/Samplers/MemorySampler.html","",""],["NewRelic::Agent::Samplers::MemorySampler::Base","","NewRelic/Agent/Samplers/MemorySampler/Base.html","",""],["NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler","","NewRelic/Agent/Samplers/MemorySampler/JavaHeapSampler.html","",""],["NewRelic::Agent::Samplers::MemorySampler::ProcStatus","","NewRelic/Agent/Samplers/MemorySampler/ProcStatus.html","","<p>ProcStatus\n<p>A class that samples memory by reading the file /proc/$$/status, which is\nspecific to linux …\n"],["NewRelic::Agent::Samplers::MemorySampler::ShellPS","","NewRelic/Agent/Samplers/MemorySampler/ShellPS.html","",""],["NewRelic::Agent::Samplers::ObjectSampler","","NewRelic/Agent/Samplers/ObjectSampler.html","",""],["NewRelic::Agent::ServerConnectionException","","NewRelic/Agent/ServerConnectionException.html","","<p>Used to blow out of a periodic task without logging a an error, such as for\nroutine failures.\n"],["NewRelic::Agent::ServerError","","NewRelic/Agent/ServerError.html","","<p>Reserved for future use.  Meant to represent a problem on the server side.\n"],["NewRelic::Agent::ShimAgent","","NewRelic/Agent/ShimAgent.html","",""],["NewRelic::Agent::SlowSql","","NewRelic/Agent/SlowSql.html","",""],["NewRelic::Agent::SqlSampler","","NewRelic/Agent/SqlSampler.html","",""],["NewRelic::Agent::SqlTrace","","NewRelic/Agent/SqlTrace.html","",""],["NewRelic::Agent::StatsEngine","","NewRelic/Agent/StatsEngine.html","","<p>This class handles all the statistics gathering for the agent\n"],["NewRelic::Agent::StatsEngine::GCProfiler","","NewRelic/Agent/StatsEngine/GCProfiler.html","",""],["NewRelic::Agent::StatsEngine::GCProfiler::Profiler","","NewRelic/Agent/StatsEngine/GCProfiler/Profiler.html","",""],["NewRelic::Agent::StatsEngine::GCProfiler::RailsBench","","NewRelic/Agent/StatsEngine/GCProfiler/RailsBench.html","",""],["NewRelic::Agent::StatsEngine::GCProfiler::Rubinius","","NewRelic/Agent/StatsEngine/GCProfiler/Rubinius.html","",""],["NewRelic::Agent::StatsEngine::GCProfiler::Ruby19","","NewRelic/Agent/StatsEngine/GCProfiler/Ruby19.html","",""],["NewRelic::Agent::StatsEngine::MetricStats","","NewRelic/Agent/StatsEngine/MetricStats.html","","<p>Handles methods related to actual Metric collection\n"],["NewRelic::Agent::StatsEngine::MetricStats::Harvest","","NewRelic/Agent/StatsEngine/MetricStats/Harvest.html","","<p>This module was extracted from the harvest method and should be refactored\n"],["NewRelic::Agent::StatsEngine::MetricStats::SynchronizedHash","","NewRelic/Agent/StatsEngine/MetricStats/SynchronizedHash.html","","<p>A simple mutex-synchronized hash to make sure our statistics are internally\nconsistent even in truly-threaded …\n"],["NewRelic::Agent::StatsEngine::Samplers","","NewRelic/Agent/StatsEngine/Samplers.html","","<p>Contains statistics engine extensions to support the concept of samplers\n"],["NewRelic::Agent::StatsEngine::ScopeStackElement","","NewRelic/Agent/StatsEngine/ScopeStackElement.html","","<p>A simple stack element that tracks the current name and length of the\nexecuting stack\n"],["NewRelic::Agent::StatsEngine::Transactions","","NewRelic/Agent/StatsEngine/Transactions.html","","<p>Handles pushing and popping elements onto an internal stack that tracks\nwhere time should be allocated …\n"],["NewRelic::Agent::TransactionInfo","","NewRelic/Agent/TransactionInfo.html","",""],["NewRelic::Agent::TransactionSampleBuilder","","NewRelic/Agent/TransactionSampleBuilder.html","","<p>a builder is created with every sampled transaction, to dynamically\ngenerate the sampled data.  It is …\n"],["NewRelic::Agent::TransactionSampler","","NewRelic/Agent/TransactionSampler.html","","<p>This class contains the logic of sampling a transaction - creation and\nmodification of transaction samples …\n"],["NewRelic::Agent::TransactionSqlData","","NewRelic/Agent/TransactionSqlData.html","",""],["NewRelic::Agent::WorkerLoop","","NewRelic/Agent/WorkerLoop.html","","<p>A worker loop executes a set of registered tasks on a single thread. A task\nis a proc or block with a …\n"],["NewRelic::ApdexStats","","NewRelic/ApdexStats.html","",""],["NewRelic::BasicStats","","NewRelic/BasicStats.html","",""],["NewRelic::ChainedCall","","NewRelic/ChainedCall.html","","<p>This class is used by NewRelic::Agent.set_sql_obfuscator to chain multiple\nobfuscation blocks when not …\n"],["NewRelic::CollectionHelper","","NewRelic/CollectionHelper.html","",""],["NewRelic::Command","","NewRelic/Command.html","",""],["NewRelic::Command::CommandFailure","","NewRelic/Command/CommandFailure.html","","<p>Capture a failure to execute the command.\n"],["NewRelic::Command::Deployments","","NewRelic/Command/Deployments.html","",""],["NewRelic::Command::Install","","NewRelic/Command/Install.html","",""],["NewRelic::Control","","NewRelic/Control.html","","<p>The Control is a singleton responsible for the startup and initialization\nsequence.  The initializer …\n"],["NewRelic::Control::ClassMethods","","NewRelic/Control/ClassMethods.html","","<p>class-level methods for lazy creation of NewRelic::Control and\nNewRelic::LocalEnvironment instances. …\n"],["NewRelic::Control::Configuration","","NewRelic/Control/Configuration.html","","<p>used to contain methods to look up settings from the configuration located\nin newrelic.yml\n"],["NewRelic::Control::Frameworks","","NewRelic/Control/Frameworks.html","","<p>Contains subclasses of NewRelic::Control that are used when starting the\nagent within an application. …\n"],["NewRelic::Control::Frameworks::External","","NewRelic/Control/Frameworks/External.html","","<p>This is the control used when starting up in the context of The New Relic\nInfrastructure Agent.  We want …\n"],["NewRelic::Control::Frameworks::Merb","","NewRelic/Control/Frameworks/Merb.html","","<p>Includes limited support for Merb\n"],["NewRelic::Control::Frameworks::Rails","","NewRelic/Control/Frameworks/Rails.html","","<p>Control subclass instantiated when Rails is detected.  Contains Rails\nspecific configuration, instrumentation, …\n"],["NewRelic::Control::Frameworks::Rails3","","NewRelic/Control/Frameworks/Rails3.html","","<p>Control subclass instantiated when Rails is detected.  Contains Rails 3.0+ \nspecific configuration, instrumentation, …\n"],["NewRelic::Control::Frameworks::Ruby","","NewRelic/Control/Frameworks/Ruby.html","","<p>A control used when no framework is detected - the default. Looks for a\nnewrelic.yml file in several …\n"],["NewRelic::Control::Frameworks::Sinatra","","NewRelic/Control/Frameworks/Sinatra.html","","<p>Contains basic control logic for Sinatra\n"],["NewRelic::Control::InstanceMethods","","NewRelic/Control/InstanceMethods.html","","<p>Contains methods that relate to the runtime usage of the control object.\nNote that these are subject …\n"],["NewRelic::Control::Instrumentation","","NewRelic/Control/Instrumentation.html","","<p>Contains methods that relate to adding and executing files that contain\ninstrumentation for the Ruby …\n"],["NewRelic::Control::LoggingMethods","","NewRelic/Control/LoggingMethods.html","","<p>Contains methods that relate to locating, creating, and writing to the log\nfile and/or standard out\n"],["NewRelic::Control::Profiling","","NewRelic/Control/Profiling.html","",""],["NewRelic::Control::ServerMethods","","NewRelic/Control/ServerMethods.html","","<p>Contains methods that deal with connecting to the server\n"],["NewRelic::DataSerialization","","NewRelic/DataSerialization.html","","<p>Handles serialization of data to disk, to save on contacting the server.\nLowers both server and client …\n"],["NewRelic::DataSerialization::ClassMethods","","NewRelic/DataSerialization/ClassMethods.html","",""],["NewRelic::DelayedJobInjection","","NewRelic/DelayedJobInjection.html","",""],["NewRelic::Instrumentation","","NewRelic/Instrumentation.html","",""],["NewRelic::Instrumentation::ActsAsSolrInstrumentation","","NewRelic/Instrumentation/ActsAsSolrInstrumentation.html","",""],["NewRelic::Instrumentation::ActsAsSolrInstrumentation::ParserMethodsInstrumentation","","NewRelic/Instrumentation/ActsAsSolrInstrumentation/ParserMethodsInstrumentation.html","",""],["NewRelic::LanguageSupport","","NewRelic/LanguageSupport.html","",""],["NewRelic::LanguageSupport::Control","","NewRelic/LanguageSupport/Control.html","",""],["NewRelic::LanguageSupport::DataSerialization","","NewRelic/LanguageSupport/DataSerialization.html","",""],["NewRelic::LanguageSupport::SynchronizedHash","","NewRelic/LanguageSupport/SynchronizedHash.html","",""],["NewRelic::LocalEnvironment","","NewRelic/LocalEnvironment.html","","<p>An instance of LocalEnvironment is responsible for determining three\nthings:\n<p>Framework - :rails, :rails3, …\n"],["NewRelic::MerbBootLoader","","NewRelic/MerbBootLoader.html","",""],["NewRelic::MethodTraceStats","","NewRelic/MethodTraceStats.html","","<p>Statistics used to track the performance of traced methods\n"],["NewRelic::MetricData","","NewRelic/MetricData.html","",""],["NewRelic::MetricSpec","","NewRelic/MetricSpec.html","","<p>this struct uniquely defines a metric, optionally inside the call scope of\nanother metric\n"],["NewRelic::Metrics","","NewRelic/Metrics.html","",""],["NewRelic::NoticedError","","NewRelic/NoticedError.html","","<p>This class encapsulates an error that was noticed by New Relic in a managed\napp.\n"],["NewRelic::Rack","","NewRelic/Rack.html","",""],["NewRelic::Rack::BrowserMonitoring","","NewRelic/Rack/BrowserMonitoring.html","",""],["NewRelic::Rack::DeveloperMode","","NewRelic/Rack/DeveloperMode.html","",""],["NewRelic::Railtie","","NewRelic/Railtie.html","",""],["NewRelic::ScopedMethodTraceStats","","NewRelic/ScopedMethodTraceStats.html","",""],["NewRelic::Stats","","NewRelic/Stats.html","",""],["NewRelic::StatsBase","","NewRelic/StatsBase.html","",""],["NewRelic::TransactionAnalysis","","NewRelic/TransactionAnalysis.html","",""],["NewRelic::TransactionAnalysis::SegmentSummary","","NewRelic/TransactionAnalysis/SegmentSummary.html","","<p>summarizes performance data for all calls to segments with the same\nmetric_name\n"],["NewRelic::TransactionSample","","NewRelic/TransactionSample.html","",""],["NewRelic::TransactionSample::CompositeSegment","","NewRelic/TransactionSample/CompositeSegment.html","",""],["NewRelic::TransactionSample::FakeSegment","","NewRelic/TransactionSample/FakeSegment.html","",""],["NewRelic::TransactionSample::Segment","","NewRelic/TransactionSample/Segment.html","",""],["NewRelic::TransactionSample::SummarySegment","","NewRelic/TransactionSample/SummarySegment.html","",""],["NewRelic::UrlRule","","NewRelic/UrlRule.html","","<p>Represents url mapping rules stored on the server.  These rules should be\napplied to URLs which are not …\n"],["NewRelic::UrlRule::RuleSet","","NewRelic/UrlRule/RuleSet.html","",""],["NewRelic::VersionNumber","","NewRelic/VersionNumber.html","","<p>Helper class for managing version comparisons\n"],["Object","","Object.html","",""],["<<","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-i-3C-3C","(segment)",""],["<=>","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-3C-3D-3E","(o)",""],["<=>","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-3C-3D-3E","(other)",""],["==","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-3D-3D","(o)",""],["[]","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-5B-5D","(key)",""],["[]","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-5B-5D","(key)",""],["[]=","NewRelic::Agent::StatsEngine::MetricStats::SynchronizedHash","NewRelic/Agent/StatsEngine/MetricStats/SynchronizedHash.html#method-i-5B-5D-3D","(*args)",""],["[]=","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-5B-5D-3D","(key, value)",""],["[]=","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-5B-5D-3D","(key, value)",""],["_call","NewRelic::Rack::DeveloperMode","NewRelic/Rack/DeveloperMode.html#method-i-_call","(env)",""],["abort_transaction!","NewRelic::Agent","NewRelic/Agent.html#method-i-abort_transaction-21","()","<p>Cancel the collection of the current transaction in progress, if any.  Only\naffects the transaction started …\n"],["abort_transaction!","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-abort_transaction-21","()","<p>Call this to ensure that the current transaction is not saved\n"],["abort_transaction!","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-abort_transaction-21","()","<p>Indicate that you don’t want to keep the currently saved transaction\ninformation\n"],["absent?","NewRelic::Stats","NewRelic/Stats.html#method-i-absent-3F","()","<p>a stat is absent if its call count equals zero\n"],["add_called_segment","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-add_called_segment","(s)",""],["add_custom_parameters","NewRelic::Agent","NewRelic/Agent.html#method-i-add_custom_parameters","(params)","<p>Add parameters to the current transaction trace (and traced error if any)\non the call stack.\n"],["add_custom_parameters","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-add_custom_parameters","(p)","<p>Add context parameters to the metric frame.  This information will be\npassed in to errors and transaction …\n"],["add_custom_parameters","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-add_custom_parameters","(p)",""],["add_force_persist_to","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-add_force_persist_to","(result)",""],["add_harvest_sampler","NewRelic::Agent::StatsEngine::Samplers","NewRelic/Agent/StatsEngine/Samplers.html#method-i-add_harvest_sampler","(sampler)","<p>Add a sampler to be invoked just before each harvest.\n"],["add_instrumentation","NewRelic::Agent","NewRelic/Agent.html#method-i-add_instrumentation","(file_pattern)","<p>Add instrumentation files to the agent.  The argument should be a glob\nmatching ruby scripts which will …\n"],["add_instrumentation","NewRelic::Control::Instrumentation","NewRelic/Control/Instrumentation.html#method-i-add_instrumentation","(pattern)","<p>Add instrumentation.  Don’t call this directly.  Use\nNewRelic::Agent#add_instrumentation. This will load …\n"],["add_method_tracer","NewRelic::Agent::MethodTracer::ClassMethods","NewRelic/Agent/MethodTracer/ClassMethods.html#method-i-add_method_tracer","(method_name, metric_name_code=nil, options = {})","<p>Add a method tracer to the specified method.\n<p>Common Options\n<p><code>:push_scope =&gt; false</code> specifies this method …\n"],["add_random_sample_to","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-add_random_sample_to","(result)","<p>Every 1/n harvests, adds the most recent sample to the harvest array if it\nexists. Makes sure that the …\n"],["add_request_parameters","NewRelic::Agent","NewRelic/Agent.html#method-i-add_request_parameters","(params)","<p>The #add_request_parameters method is aliased to #add_custom_parameters and\nis now deprecated.\n"],["add_sampler","NewRelic::Agent::StatsEngine::Samplers","NewRelic/Agent/StatsEngine/Samplers.html#method-i-add_sampler","(sampler)","<p>Add an instance of Sampler to be invoked about every 10 seconds on a\nbackground thread.\n"],["add_samples_to","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-add_samples_to","(result, slow_threshold)","<p>Returns an array of slow samples, with either one or two elements - one\nelement unless random sampling …\n"],["add_segments","NewRelic::TransactionSample::SummarySegment","NewRelic/TransactionSample/SummarySegment.html#method-i-add_segments","(segments)",""],["add_to_error_queue","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-add_to_error_queue","(noticed_error)","<p>Synchronizes adding an error to the error queue, and checks if the error\nqueue is too long - if so, we …\n"],["add_transaction_tracer","NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods","NewRelic/Agent/Instrumentation/ControllerInstrumentation/ClassMethods.html#method-i-add_transaction_tracer","(method, options={})","<p>Add transaction tracing to the given method.  This will treat the given\nmethod as a main entrypoint for …\n"],["after_fork","NewRelic::Agent","NewRelic/Agent.html#method-i-after_fork","(options={})","<p>Register this method as a callback for processes that fork jobs.\n<p>If the master/parent connects to the …\n"],["after_fork","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-after_fork","(options={})","<p>This method should be called in a forked process after a fork. It assumes\nthe parent process initialized …\n"],["after_fork","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-after_fork","(*args;)",""],["after_fork","Object","Object.html#method-i-after_fork","()",""],["after_fork_with_newrelic","Object","Object.html#method-i-after_fork_with_newrelic","()",""],["agent","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-agent","()",""],["agent_config","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-agent_config","()",""],["agent_enabled?","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-agent_enabled-3F","()","<p>True if dev mode or monitor mode are enabled, and we are running inside a\nvalid dispatcher like mongrel …\n"],["agent_instance","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-agent_instance","()","<p>Shorthand to return the NewRelic::Agent.instance\n"],["aggregate","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-aggregate","(slow_sql, path, uri)",""],["already_started?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-already_started-3F","()","<p>Check whether we have already started, which is an error condition\n"],["any_unrecognized_keys?","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-any_unrecognized_keys-3F","(expected, given)","<p>used to verify that the keys passed to\nNewRelic::Agent::MethodTracer::ClassMethods#add_method_tracer …\n"],["apdex_f","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-apdex_f","()","<p>apdex_f is always 4 times the apdex_t\n"],["apdex_f_threshold?","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-apdex_f_threshold-3F","()","<p>If the transaction threshold is set to the string ‘apdex_f’, we use 4\ntimes the apdex_t value to record …\n"],["apdex_score","NewRelic::Stats","NewRelic/Stats.html#method-i-apdex_score","()",""],["apdex_t","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-apdex_t","()",""],["api_server","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-api_server","()","<p>the server we should contact for api requests, like uploading deployments\nand the like\n"],["app","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-app","()","<p>Asks the LocalEnvironment instance which framework should be loaded\n"],["app_names","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-app_names","()",""],["append_backtrace","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-append_backtrace","(segment, duration)","<p>Appends a backtrace to a segment if that segment took longer than the\nspecified duration\n"],["append_environment_info","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-append_environment_info","()","<p>Collect the Rails::Info into an associative array as well as the list of\nplugins\n"],["append_environment_info","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-append_environment_info","()","<p>Collect the Rails::Info into an associative array as well as the list of\nplugins\n"],["append_environment_info","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-append_environment_info","()","<p>Append framework specific environment information for uploading to the\nserver for change detection.  …\n"],["append_environment_value","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-append_environment_value","(name, value = nil)","<p>Add the given key/value pair to the app environment settings.  Must pass\neither a value or a block.  …\n"],["append_gem_list","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-append_gem_list","()","<p>yields to the block and appends the returned value to the list of gems -\nthis catches errors that might …\n"],["append_new_message","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-append_new_message","(old_message, message)","<p>Allows the addition of multiple pieces of metadata to one segment - i.e.\ntraced method calls multiple …\n"],["append_plugin_list","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-append_plugin_list","()","<p>yields to the block and appends the returned value to the list of plugins -\nthis catches errors that …\n"],["apply","NewRelic::UrlRule","NewRelic/UrlRule.html#method-i-apply","(url)",""],["as_percentage","NewRelic::Stats","NewRelic/Stats.html#method-i-as_percentage","()","<p>the stat total_call_time is a percent\n"],["as_percentage_of","NewRelic::Stats","NewRelic/Stats.html#method-i-as_percentage_of","(other_stats)",""],["assemble_code_header","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-assemble_code_header","(method_name, metric_name_code, options)","<p>Returns a code snippet to be eval’d that skips tracing when the agent is\nnot tracing execution. turns …\n"],["autoinstrument_source","NewRelic::Rack::BrowserMonitoring","NewRelic/Rack/BrowserMonitoring.html#method-i-autoinstrument_source","(response, headers)",""],["average_call_time","NewRelic::Stats","NewRelic/Stats.html#method-i-average_call_time","()",""],["average_exclusive_time","NewRelic::Stats","NewRelic/Stats.html#method-i-average_exclusive_time","()",""],["average_exclusive_time","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-i-average_exclusive_time","()",""],["average_response_time","NewRelic::Stats","NewRelic/Stats.html#method-i-average_response_time","()",""],["average_time","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-i-average_time","()",""],["average_value","NewRelic::Stats","NewRelic/Stats.html#method-i-average_value","()",""],["begin_time","NewRelic::StatsBase","NewRelic/StatsBase.html#method-i-begin_time","()",""],["begin_time=","NewRelic::StatsBase","NewRelic/StatsBase.html#method-i-begin_time-3D","(t)","<p>In this class, we explicitly don’t track begin and end time here, to save\nspace during cross process …\n"],["breakdown_data","NewRelic::TransactionAnalysis","NewRelic/TransactionAnalysis.html#method-i-breakdown_data","(limit = nil)","<p>return the data that breaks down the performance of the transaction as an\narray of SegmentSummary objects. …\n"],["browser_monitoring_auto_instrument?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-browser_monitoring_auto_instrument-3F","()","<p>whether we should install the NewRelic::Rack::BrowserMonitoring middleware\nautomatically on Rails applications …\n"],["browser_timing_footer","NewRelic::Agent","NewRelic/Agent.html#method-i-browser_timing_footer","()","<p>Returns a Javascript string which should be injected into the very bottom\nof the response body\n"],["browser_timing_footer","NewRelic::Agent::BrowserMonitoring","NewRelic/Agent/BrowserMonitoring.html#method-i-browser_timing_footer","()","<p>This method returns a string suitable for inclusion in a page\n<p>known as ‘manual instrumentation’ for Real …\n\n"],["browser_timing_footer","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-browser_timing_footer","()",""],["browser_timing_header","NewRelic::Agent","NewRelic/Agent.html#method-i-browser_timing_header","()","<p>Returns a Javascript string which should be injected into the very top of\nthe response body\n"],["browser_timing_header","NewRelic::Agent::BrowserMonitoring","NewRelic/Agent/BrowserMonitoring.html#method-i-browser_timing_header","()","<p>This method returns a string suitable for inclusion in a page\n<p>known as ‘manual instrumentation’ for Real …\n\n"],["browser_timing_header","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-browser_timing_header","()",""],["build_browser_timing_header","NewRelic::Agent::BeaconConfiguration","NewRelic/Agent/BeaconConfiguration.html#method-i-build_browser_timing_header","()","<p>Returns the header string, properly html-safed if needed\n"],["build_load_file_js","NewRelic::Agent::BeaconConfiguration","NewRelic/Agent/BeaconConfiguration.html#method-i-build_load_file_js","(connect_data)","<p>returns a snippet of text that does not change per-transaction. Is empty\nwhen rum is disabled, or we …\n"],["builder","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-builder","()","<p>The current thread-local transaction sample builder\n"],["bundler_gem_list","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-bundler_gem_list","()","<p>Asks bundler to tell us which gemspecs are loaded in the current process\n"],["busy_count","NewRelic::Agent::BusyCalculator","NewRelic/Agent/BusyCalculator.html#method-i-busy_count","()","<p>this returns the size of the entry point stack, which determines how many\ntransactions are running\n"],["call","NewRelic::ChainedCall","NewRelic/ChainedCall.html#method-i-call","(sql)",""],["call","NewRelic::Rack::BrowserMonitoring","NewRelic/Rack/BrowserMonitoring.html#method-i-call","(env)","<p>method required by Rack interface\n"],["call","NewRelic::Rack::DeveloperMode","NewRelic/Rack/DeveloperMode.html#method-i-call","(env)",""],["call_count","NewRelic::Agent::StatsEngine::GCProfiler::RailsBench","NewRelic/Agent/StatsEngine/GCProfiler/RailsBench.html#method-i-call_count","()",""],["call_count","NewRelic::Agent::StatsEngine::GCProfiler::Rubinius","NewRelic/Agent/StatsEngine/GCProfiler/Rubinius.html#method-i-call_count","()",""],["call_count","NewRelic::Agent::StatsEngine::GCProfiler::Ruby19","NewRelic/Agent/StatsEngine/GCProfiler/Ruby19.html#method-i-call_count","()",""],["call_time","NewRelic::Agent::StatsEngine::GCProfiler::RailsBench","NewRelic/Agent/StatsEngine/GCProfiler/RailsBench.html#method-i-call_time","()",""],["call_time","NewRelic::Agent::StatsEngine::GCProfiler::Rubinius","NewRelic/Agent/StatsEngine/GCProfiler/Rubinius.html#method-i-call_time","()",""],["call_time","NewRelic::Agent::StatsEngine::GCProfiler::Ruby19","NewRelic/Agent/StatsEngine/GCProfiler/Ruby19.html#method-i-call_time","()",""],["call_with_newrelic","NewRelic::Agent::Instrumentation::Rack","NewRelic/Agent/Instrumentation/Rack.html#method-i-call_with_newrelic","(*args)",""],["called_segments","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-called_segments","()",""],["called_segments=","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-called_segments-3D","(segments)",""],["calls_per_minute","NewRelic::Stats","NewRelic/Stats.html#method-i-calls_per_minute","()",""],["can_run?","NewRelic::Agent::Samplers::MemorySampler::Base","NewRelic/Agent/Samplers/MemorySampler/Base.html#method-i-can_run-3F","()",""],["capture","NewRelic::Agent::StatsEngine::GCProfiler","NewRelic/Agent/StatsEngine/GCProfiler.html#method-c-capture","()",""],["capture","NewRelic::Agent::StatsEngine::GCProfiler::Profiler","NewRelic/Agent/StatsEngine/GCProfiler/Profiler.html#method-i-capture","()",""],["capture_params","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-capture_params","()",""],["capture_segment_trace","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-capture_segment_trace","()","<p>in developer mode, capture the stack trace with the segment. this is cpu\nand memory expensive and therefore …\n"],["catch_errors","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-catch_errors","()","<p>a wrapper method to handle all the errors that can happen in the connection\nand worker thread system. …\n"],["cert_file_path","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-cert_file_path","()","<p>The path to the certificate file used to verify the SSL connection if\nverify_peer is enabled\n"],["check_config_and_start_agent","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-check_config_and_start_agent","()","<p>Sanity-check the agent configuration and start the agent, setting up the\nworker thread and the exit handler …\n"],["check_for_illegal_keys!","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-check_for_illegal_keys-21","(options)","<p>raises an error when the\nNewRelic::Agent::MethodTracer::ClassMethods#add_method_tracer method is\ncalled …\n"],["check_for_push_scope_and_metric","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-check_for_push_scope_and_metric","(options)","<p>validity checking - add_method_tracer must receive either push scope or\nmetric, or else it would record …\n"],["check_server_connection=","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-check_server_connection-3D","(value)",""],["check_sql_sampler_status","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-check_sql_sampler_status","()",""],["check_transaction_sampler_status","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-check_transaction_sampler_status","()","<p>disable transaction sampling if disabled by the server and we’re not in\ndev mode\n"],["checked_calculation","NewRelic::Stats","NewRelic/Stats.html#method-i-checked_calculation","(numerator, denominator)","<p>makes sure we aren’t dividing by zero\n"],["clamp_number_tts","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-clamp_number_tts","(tts, limit)","<p>JON - THIS CODE NEEDS A UNIT TEST\n"],["clear","NewRelic::Agent::StatsEngine::MetricStats::SynchronizedHash","NewRelic/Agent/StatsEngine/MetricStats/SynchronizedHash.html#method-i-clear","(*args)",""],["clear","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-c-clear","()",""],["clear_builder","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-clear_builder","()","<p>Sets the thread local variable storing the transaction sample builder to\nnil to clear it\n"],["clear_stats","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-clear_stats","()","<p>Remove all stats.  For test code only.\n"],["clear_thread_metric_frame!","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-clear_thread_metric_frame-21","()",""],["clear_transaction_data","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-clear_transaction_data","()",""],["close_connections","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-close_connections","()",""],["close_connections","NewRelic::Agent::Database::ConnectionManager","NewRelic/Agent/Database/ConnectionManager.html#method-i-close_connections","()","<p>Closes all the connections in the internal connection cache\n"],["code_to_eval","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-code_to_eval","(method_name, metric_name_code, options)","<p>Decides which code snippet we should be eval’ing in this context, based\non the options.\n"],["command","NewRelic::Command::Deployments","NewRelic/Command/Deployments.html#method-c-command","()",""],["command","NewRelic::Command::Install","NewRelic/Command/Install.html#method-c-command","()",""],["config","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-config","()",""],["config","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-config","()",""],["config","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-config","()",""],["config=","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-config-3D","(other)",""],["config_file","NewRelic::Control::Frameworks::Ruby","NewRelic/Control/Frameworks/Ruby.html#method-i-config_file","()","<p>Check a sequence of file locations for newrelic.yml\n"],["config_file","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-config_file","()","<p>path to the config file, defaults to the “#{root}/config/newrelic.yml”\n"],["config_transaction_tracer","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-config_transaction_tracer","()","<p>this entire method should be done on the transaction sampler object, rather\nthan here. We should pass …\n"],["configure!","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-configure-21","()",""],["configure!","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-configure-21","()",""],["configure_error_collector!","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-configure_error_collector-21","(server_enabled)","<p>Configures the error collector if the server says that we are allowed to\nsend errors. Pretty simple, …\n"],["configure_transaction_tracer!","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-configure_transaction_tracer-21","(server_enabled, sample_rate)","<p>Enables or disables the transaction tracer and sets its options based on\nthe options provided to the …\n"],["connect_in_foreground","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-connect_in_foreground","()","<p>Connecting in the foreground blocks further startup of the agent until we\nhave a connection - useful …\n"],["connect_settings","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-connect_settings","()","<p>Initializes the hash of settings that we send to the server. Returns a\nliteral hash containing the options …\n"],["connect_to_server","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-connect_to_server","()","<p>Does some simple logging to make sure that our seed and token for\nverification are correct, then returns …\n"],["connected?","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-connected-3F","()","<p>Return nil if not yet connected, true if successfully started and false if\nwe failed to start.\n"],["content","NewRelic::Command::Install","NewRelic/Command/Install.html#method-i-content","()",""],["control","NewRelic::Agent::ErrorCollector","NewRelic/Agent/ErrorCollector.html#method-i-control","()","<p>Helper method to get the NewRelic::Control.instance\n"],["convert_to_ip_address","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-convert_to_ip_address","(host)","<p>Check to see if we need to look up the IP address If it’s an IP address\nalready, we pass it through. …\n"],["correct_license_length","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-correct_license_length","()","<p>A license key is an arbitrary 40 character string, usually looks something\nlike a SHA1 hash\n"],["count_segments","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-count_segments","()",""],["count_segments","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-count_segments","()",""],["cpu_burn","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-cpu_burn","()",""],["create_and_run_worker_loop","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-create_and_run_worker_loop","()","<p>Creates the worker loop and loads it with the instructions it should run\nevery @report_period seconds …\n"],["create_segment","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-create_segment","(relative_timestamp, metric_name, segment_id = nil)",""],["create_transaction_data","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-create_transaction_data","()",""],["current","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-current","(create_if_empty=nil)","<p>Return the currently active metric frame, or nil.  Call with\n<code>true</code> to create a new metric frame if one …\n"],["current_metric","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-current_metric","()",""],["current_sample_id","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-current_sample_id","()","<p>Returns the current sample id, delegated from `builder`\n"],["current_stack_metric","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-current_stack_metric","()",""],["custom_parameters","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-custom_parameters","()",""],["custom_parameters","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-custom_parameters","()",""],["custom_params_from_opts","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-custom_params_from_opts","(options)","<p>If anything else is left over, we treat it like a custom param\n"],["database_metric_name","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-database_metric_name","()","<p>This is the name of the model currently assigned to database measurements,\noverriding the default.\n"],["database_time","NewRelic::TransactionAnalysis","NewRelic/TransactionAnalysis.html#method-i-database_time","()",""],["default_metric_name_code","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-default_metric_name_code","(method_name)","<p>Default to the class where the method is defined.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Foo</span>.<span class=\"ruby-identifier\">default_metric_name_code</span>(<span class=\"ruby-string\">'bar'</span>) <span class=\"ruby-comment\">#=&gt; &quot;Custom/#{Foo.name}/bar&quot;</span>\n</pre>\n"],["default_sql_obfuscator","NewRelic::Agent::Database::Obfuscator","NewRelic/Agent/Database/Obfuscator.html#method-i-default_sql_obfuscator","(sql)",""],["deferred_work!","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-deferred_work-21","(connection_options)","<p>This is the method that is run in a new thread in order to background the\nharvesting and sending of data …\n"],["delete","NewRelic::Agent::StatsEngine::MetricStats::SynchronizedHash","NewRelic/Agent/StatsEngine/MetricStats/SynchronizedHash.html#method-i-delete","(*args)",""],["delete_if","NewRelic::Agent::StatsEngine::MetricStats::SynchronizedHash","NewRelic/Agent/StatsEngine/MetricStats/SynchronizedHash.html#method-i-delete_if","(*args)",""],["detail_segments=","NewRelic::TransactionSample::CompositeSegment","NewRelic/TransactionSample/CompositeSegment.html#method-i-detail_segments-3D","(segments)",""],["developer_mode?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-developer_mode-3F","()","<p>True if we are capturing data and displaying in /newrelic\n"],["disable","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-disable","()","<p>Disable the sql sampler - this also deregisters it with the statistics\nengine.\n"],["disable","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-disable","()","<p>Disable the transaction sampler - this also deregisters it with the\nstatistics engine.\n"],["disable_all_tracing","NewRelic::Agent","NewRelic/Agent.html#method-i-disable_all_tracing","()","<p>Yield to the block without collecting any metrics or traces in any of the\nsubsequent calls.  If executed …\n"],["disable_backtrace_cleanup?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-disable_backtrace_cleanup-3F","()",""],["disable_serialization=","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-disable_serialization-3D","(b)",""],["disable_serialization?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-disable_serialization-3F","()",""],["disable_sql_recording","NewRelic::Agent","NewRelic/Agent.html#method-i-disable_sql_recording","()","<p>This method sets the state of sql recording in the transaction sampler\nfeature. Within the given block, …\n"],["disable_transaction_tracing","NewRelic::Agent","NewRelic/Agent.html#method-i-disable_transaction_tracing","()","<p>This method disables the recording of transaction traces in the given\nblock.  See also #disable_all_tracing …\n"],["disabled?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-disabled-3F","()","<p>The agent is disabled when it is not force enabled by the\n‘agent_enabled’ option (e.g. in a manual start), …\n"],["disabled?","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-disabled-3F","()","<p>Whether the error collector is disabled or not\n"],["disconnect","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-disconnect","()","<p>Disconnect just sets connected to false, which prevents the agent from\ntrying to connect again\n"],["dispatcher","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-dispatcher","()",""],["dispatcher_finish","NewRelic::Agent::BusyCalculator","NewRelic/Agent/BusyCalculator.html#method-i-dispatcher_finish","(end_time = Time.now)","<p>called when a transaction finishes, to add time to the instance variable\naccumulator. this is harvested …\n"],["dispatcher_instance_id","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-dispatcher_instance_id","()",""],["dispatcher_instance_id","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-dispatcher_instance_id","()","<p>An instance id pulled from either @dispatcher_instance_id or by splitting\nout the first part of the running …\n"],["dispatcher_start","NewRelic::Agent::BusyCalculator","NewRelic/Agent/BusyCalculator.html#method-i-dispatcher_start","(time)","<p>sets up busy calculations based on the start and end of transactions - used\nfor a rough estimate of what …\n"],["do_not_trace?","NewRelic::Agent::Instrumentation::ControllerInstrumentation","NewRelic/Agent/Instrumentation/ControllerInstrumentation.html#method-i-do_not_trace-3F","()","<p>overrideable method to determine whether to trace an action or not - you\nmay override this in your controller …\n"],["duration","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-i-duration","()",""],["duration","NewRelic::Stats","NewRelic/Stats.html#method-i-duration","()",""],["duration","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-duration","()",""],["duration","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-duration","()","<p>return the total duration of this segment\n"],["each","NewRelic::LanguageSupport::SynchronizedHash","NewRelic/LanguageSupport/SynchronizedHash.html#method-i-each","(*args, &block)",""],["each_segment","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-each_segment","(&block)","<p>Iterates recursively over each segment in the entire transaction sample\ntree\n"],["each_segment","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-each_segment","(&block)","<p>call the provided block for this segment and each of the called segments\n"],["each_segment_with_nest_tracking","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-each_segment_with_nest_tracking","(&block)","<p>Iterates recursively over each segment in the entire transaction sample\ntree while keeping track of nested …\n"],["each_segment_with_nest_tracking","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-each_segment_with_nest_tracking","(&block)","<p>call the provided block for this segment and each of the called segments\nwhile keeping track of nested …\n"],["enable","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-enable","()","<p>Enable the sql sampler - this also registers it with the statistics engine.\n"],["enable","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-enable","()","<p>Enable the transaction sampler - this also registers it with the statistics\nengine.\n"],["enable_random_samples!","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-enable_random_samples-21","(sample_rate)","<p>Random sampling is enabled based on a sample rate, which is the n in\n“every 1/n transactions is …\n"],["enabled?","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-enabled-3F","()",""],["enabled?","NewRelic::Agent::StatsEngine::GCProfiler::RailsBench","NewRelic/Agent/StatsEngine/GCProfiler/RailsBench.html#method-c-enabled-3F","()",""],["enabled?","NewRelic::Agent::StatsEngine::GCProfiler::Rubinius","NewRelic/Agent/StatsEngine/GCProfiler/Rubinius.html#method-c-enabled-3F","()",""],["enabled?","NewRelic::Agent::StatsEngine::GCProfiler::Ruby19","NewRelic/Agent/StatsEngine/GCProfiler/Ruby19.html#method-c-enabled-3F","()",""],["enabled?","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-enabled-3F","()",""],["end_time","NewRelic::StatsBase","NewRelic/StatsBase.html#method-i-end_time","()",""],["end_time=","NewRelic::StatsBase","NewRelic/StatsBase.html#method-i-end_time-3D","(t)",""],["end_trace","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-end_trace","(timestamp)","<p>sets the final timestamp on a segment to indicate the exit point of the\nsegment\n"],["end_transaction","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-end_transaction","()","<p>Tells the statistics engine we are ending a transaction\n"],["end_transaction","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-end_transaction","()","<p>Try to clean up gracefully, otherwise we leave things hanging around on\nthread locals. If it looks like …\n"],["end_transaction!","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-end_transaction-21","()",""],["ensure_segment_count_set","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-ensure_segment_count_set","(count)","<p>makes sure that the parameter cache for segment count is set to the correct\nvalue\n"],["env","NewRelic::Control::Frameworks::Merb","NewRelic/Control/Frameworks/Merb.html#method-i-env","()",""],["env","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-env","()",""],["env","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-env","()",""],["env","NewRelic::Control::Frameworks::Ruby","NewRelic/Control/Frameworks/Ruby.html#method-i-env","()",""],["env","NewRelic::Control::Frameworks::Sinatra","NewRelic/Control/Frameworks/Sinatra.html#method-i-env","()",""],["environment_for_connect","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-environment_for_connect","()","<p>Checks whether we should send environment info, and if so, returns the\nsnapshot from the local environment …\n"],["eql?","NewRelic::MetricData","NewRelic/MetricData.html#method-i-eql-3F","(o)",""],["eql?","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-eql-3F","(o)",""],["eql?","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-eql-3F","(other)",""],["err","NewRelic::Command","NewRelic/Command.html#method-i-err","(message)",""],["error_is_ignored?","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-error_is_ignored-3F","(error)","<p>an error is ignored if it is nil or if it is filtered\n"],["error_params_from_options","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-error_params_from_options","(options)","<p>Merges together many of the options into something that can actually be\nattached to the error\n"],["exception_info","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-exception_info","(exception)","<p>extracts a bunch of information from the exception to include in the\nnoticed error - some may or may …\n"],["exclusive_duration","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-exclusive_duration","()","<p>return the duration of this segment without including the time in the\ncalled segments\n"],["exclusive_time_percentage","NewRelic::Stats","NewRelic/Stats.html#method-i-exclusive_time_percentage","()",""],["exclusive_time_percentage","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-i-exclusive_time_percentage","()",""],["expand_min_max_to","NewRelic::Stats","NewRelic/Stats.html#method-i-expand_min_max_to","(other)",""],["explain","NewRelic::Agent::SlowSql","NewRelic/Agent/SlowSql.html#method-i-explain","()",""],["explain_sql","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-explain_sql","(sql, connection_config)","<p>Perform this in the runtime environment of a managed application, to\nexplain the sql statement executed …\n"],["explain_sql","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-explain_sql","()",""],["explain_statement","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-explain_statement","(statement, config)",""],["extract_source","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-extract_source","(exception)","<p>extracts source from the exception, if the exception supports that method\n"],["extract_stack_trace","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-extract_stack_trace","(exception)","<p>extracts a stack trace from the exception for debugging purposes\n"],["fetch","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-fetch","(key, default=nil)",""],["fetch_from_options","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-fetch_from_options","(options, key, default=nil)","<p>acts just like Hash#fetch, but deletes the key from the hash\n"],["filtered_by_error_filter?","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-filtered_by_error_filter-3F","(error)","<p>Checks the provided error against the error filter, if there is an error\nfilter\n"],["filtered_error?","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-filtered_error-3F","(error)","<p>Checks the array of error names and the error filter against the provided\nerror\n"],["find_class_in_object_space","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-find_class_in_object_space","(klass)","<p>Runs through all the objects in ObjectSpace to find the first one that\nmatch the provided class\n"],["find_or_create_file_path","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-find_or_create_file_path","(path_setting)",""],["find_segment","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-find_segment","(id)","<p>Searches the tree recursively for the segment with the given id. note that\nthis is an internal id, not …\n"],["find_segment","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-find_segment","(id)",""],["finish_command","NewRelic::Agent::BeaconConfiguration","NewRelic/Agent/BeaconConfiguration.html#method-i-finish_command","()","<p>RUM footer command used for ‘finish’ - based on whether JSONP is being\nused. ‘nrfj’ for JSONP, otherwise …\n"],["finish_setup","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-finish_setup","(config_data)","<p>Takes a hash of configuration data returned from the server and uses it to\nset local variables and to …\n"],["finish_trace","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-finish_trace","(time)",""],["force_persist_sample?","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-i-force_persist_sample-3F","(sample)",""],["fraction_of","NewRelic::Stats","NewRelic/Stats.html#method-i-fraction_of","(s)","<p>calculate this set of stats to be a percentage fraction of the provided\nstats, which has an overlapping …\n"],["framework","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-framework","()",""],["freeze","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-freeze","()",""],["freeze","NewRelic::StatsBase","NewRelic/StatsBase.html#method-i-freeze","()",""],["gather_ar_adapter_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_ar_adapter_info","()","<p>The name of the AR database adapter for the current environment and the\ncurrent schema version\n"],["gather_architecture_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_architecture_info","()","<p>Grabs the architecture string from either `uname -p` or the env variable\nPROCESSOR_ARCHITECTURE\n"],["gather_cpu_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_cpu_info","()","<p>See what the number of cpus is, works only on some linux variants\n"],["gather_db_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_db_info","()","<p>sensing for which adapter is defined, then appends the relevant config\ninformation\n"],["gather_dm_adapter_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_dm_adapter_info","()","<p>Datamapper version\n"],["gather_environment_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_environment_info","()","<p>Collect base statistics about the environment and record them for\ncomparison and change detection.\n"],["gather_jruby_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_jruby_info","()","<p>like gather_ruby_info but for the special case of JRuby\n"],["gather_os_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_os_info","()","<p>gathers OS info from either `uname -v`, `uname -s`, or the OS env variable\n"],["gather_revision_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_revision_info","()","<p>Looks for a capistrano file indicating the current revision\n"],["gather_ruby_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_ruby_info","()","<p>Interrogates some common ruby constants for useful information about what\nkind of ruby environment the …\n"],["gather_system_info","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-gather_system_info","()","<p>Gathers the architecture and cpu info\n"],["get","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-c-get","()",""],["get_apdex","NewRelic::Stats","NewRelic/Stats.html#method-i-get_apdex","()","<p>returns s,t,f\n"],["get_connection","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-get_connection","(config)",""],["get_connection","NewRelic::Agent::Database::ConnectionManager","NewRelic/Agent/Database/ConnectionManager.html#method-i-get_connection","(config)","<p>Returns a cached connection for a given ActiveRecord configuration - these\nare stored or reopened as …\n"],["get_custom_stats","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-get_custom_stats","(metric_name, stat_class)","<p>This version allows a caller to pass a stat class to use\n"],["get_memory","NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler","NewRelic/Agent/Samplers/MemorySampler/JavaHeapSampler.html#method-i-get_memory","()",""],["get_memory","NewRelic::Agent::Samplers::MemorySampler::ProcStatus","NewRelic/Agent/Samplers/MemorySampler/ProcStatus.html#method-i-get_memory","()","<p>Returns the amount of resident memory this process is using in MB\n"],["get_memory","NewRelic::Agent::Samplers::MemorySampler::ShellPS","NewRelic/Agent/Samplers/MemorySampler/ShellPS.html#method-i-get_memory","()","<p>Returns the amount of resident memory this process is using in MB\n"],["get_metric_stats","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-get_metric_stats","(metrics, options)","<p>returns an array containing the first metric, and an array of other\nunscoped statistics we should also …\n"],["get_retry_period","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-get_retry_period","()","<p>Retry period is a minute for each failed attempt that we’ve made. This\nshould probably do some sort of …\n"],["get_sample","NewRelic::Agent::Samplers::MemorySampler::Base","NewRelic/Agent/Samplers/MemorySampler/Base.html#method-i-get_sample","()",""],["get_stats","NewRelic::Agent","NewRelic/Agent.html#method-i-get_stats","(metric_name, use_scope=false)","<p>Get or create a statistics gatherer that will aggregate numerical data\nunder a metric name.\n<p><code>metric_name</code> …\n"],["get_stats","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-get_stats","(metric_name, use_scope = true, scoped_metric_only = false, scope = nil)","<p>If use_scope is true, two chained metrics are created, one with scope and\none without If scoped_metric_only …\n"],["get_stats_no_scope","NewRelic::Agent","NewRelic/Agent.html#method-i-get_stats_no_scope","(metric_name, use_scope=false)",""],["get_stats_no_scope","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-get_stats_no_scope","(metric_name)","<p>a simple accessor for looking up a stat with no scope - returns a new stats\nobject if no stats object …\n"],["get_stats_scoped","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-get_stats_scoped","(first_name, scoped_metric_only)","<p>returns a scoped metric stat for the specified name\n"],["get_stats_unscoped","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-get_stats_unscoped","(name)","<p>Shorthand method to get stats from the stat engine\n"],["guid","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-i-guid","()",""],["guid=","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-i-guid-3D","(value)",""],["handle_empty_path_stack","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-handle_empty_path_stack","(metric)",""],["handle_exception_in_explain","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-handle_exception_in_explain","()",""],["handle_force_disconnect","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-handle_force_disconnect","(error)","<p>when a disconnect is requested, stop the current thread, which is the\nworker thread that gathers data …\n"],["handle_force_restart","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-handle_force_restart","(error)","<p>Handles the case where the server tells us to restart - this clears the\ndata, clears connection attempts, …\n"],["handle_license_error","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-handle_license_error","(error)","<p>When the server sends us an error with the license key, we want to tell the\nuser that something went …\n"],["handle_other_error","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-handle_other_error","(error)","<p>Handles an unknown error in the worker thread by logging it and\ndisconnecting the agent, since we are …\n"],["handle_server_connection_problem","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-handle_server_connection_problem","(error)","<p>there is a problem with connecting to the server, so we stop trying to\nconnect and shut down the agent …\n"],["harvest","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-harvest","()",""],["harvest","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-harvest","(previous = [], slow_threshold = 2.0)","<p>get the set of collected samples, merging into previous samples, and clear\nthe collected sample list. …\n"],["harvest_busy","NewRelic::Agent::BusyCalculator","NewRelic/Agent/BusyCalculator.html#method-i-harvest_busy","()","<p>Called before uploading to to the server to collect current busy stats.\n"],["harvest_errors","NewRelic::Agent::ErrorCollector","NewRelic/Agent/ErrorCollector.html#method-i-harvest_errors","(unsent_errors)","<p>Get the errors currently queued up.  Unsent errors are left over from a\nprevious unsuccessful attempt …\n"],["harvest_slow_sql","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-harvest_slow_sql","(transaction_sql_data)","<p>this should always be called under the @samples_lock\n"],["harvest_timeslice_data","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-harvest_timeslice_data","(previous_timeslice_data, metric_ids)","<p>Harvest the timeslice data.  First recombine current statss with any\npreviously unsent metrics, clear …\n"],["has_correct_license_key?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-has_correct_license_key-3F","()","<p>A correct license key exists and is of the proper length\n"],["has_license_key?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-has_license_key-3F","()","<p>Tell the user when the license key is missing so they can fix it by adding\nit to the file\n"],["hash","NewRelic::MetricData","NewRelic/MetricData.html#method-i-hash","()",""],["hash","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-hash","()",""],["hash","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-hash","()",""],["http_connection","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-http_connection","(host = nil)","<p>Return the Net::HTTP with proxy configuration given the\nNewRelic::Control::Server object. Default is …\n"],["ignore","NewRelic::Agent::ErrorCollector","NewRelic/Agent/ErrorCollector.html#method-i-ignore","(errors)","<p>errors is an array of Exception Class Names\n"],["ignore_apdex?","NewRelic::Agent::Instrumentation::ControllerInstrumentation","NewRelic/Agent/Instrumentation/ControllerInstrumentation.html#method-i-ignore_apdex-3F","()","<p>overrideable method to determine whether to trace an action for purposes of\napdex measurement - you can …\n"],["ignore_error_filter","NewRelic::Agent","NewRelic/Agent.html#method-i-ignore_error_filter","(&block)","<p>Set a filter to be applied to errors that the Ruby Agent will track.  The\nblock should evalute to the …\n"],["ignore_error_filter","NewRelic::Agent::ErrorCollector","NewRelic/Agent/ErrorCollector.html#method-i-ignore_error_filter","(&block)","<p>Returns the error filter proc that is used to check if an error should be\nreported. When given a block, …\n"],["ignore_transaction","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-ignore_transaction","()",""],["ignore_transaction","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-ignore_transaction","()","<p>Tells the builder to ignore a transaction, if we are currently creating\none. Only causes the sample to …\n"],["ignored?","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-ignored-3F","()",""],["include_guid?","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-i-include_guid-3F","()",""],["included","NewRelic::Agent::Instrumentation::ActiveRecordInstrumentation","NewRelic/Agent/Instrumentation/ActiveRecordInstrumentation.html#method-c-included","(instrumented_class)",""],["included","NewRelic::Agent::Instrumentation::DataMapperInstrumentation","NewRelic/Agent/Instrumentation/DataMapperInstrumentation.html#method-c-included","(klass)",""],["included","NewRelic::LanguageSupport::Control","NewRelic/LanguageSupport/Control.html#method-c-included","(base)",""],["included","NewRelic::LanguageSupport::DataSerialization","NewRelic/LanguageSupport/DataSerialization.html#method-c-included","(base)",""],["included","NewRelic::LanguageSupport::SynchronizedHash","NewRelic/LanguageSupport/SynchronizedHash.html#method-c-included","(base)",""],["increment_count","NewRelic::MethodTraceStats","NewRelic/MethodTraceStats.html#method-i-increment_count","(value = 1)","<p>increments the call_count by one\n"],["increment_error_count!","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-increment_error_count-21","()","<p>Increments a statistic that tracks total error rate\n"],["info","NewRelic::Command","NewRelic/Command.html#method-i-info","(message)",""],["inherited","NewRelic::Agent::Sampler","NewRelic/Agent/Sampler.html#method-c-inherited","(subclass)",""],["inherited","NewRelic::Command","NewRelic/Command.html#method-c-inherited","(subclass)",""],["init","NewRelic::Agent::StatsEngine::GCProfiler","NewRelic/Agent/StatsEngine/GCProfiler.html#method-c-init","()",""],["init_config","NewRelic::Control::Frameworks::External","NewRelic/Control/Frameworks/External.html#method-i-init_config","(options={})",""],["init_config","NewRelic::Control::Frameworks::Merb","NewRelic/Control/Frameworks/Merb.html#method-i-init_config","(options={})",""],["init_config","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-init_config","(options={})","<p>In versions of Rails prior to 2.0, the rails config was only available to\nthe init.rb, so it had to be …\n"],["init_config","NewRelic::Control::Frameworks::Ruby","NewRelic/Control/Frameworks/Ruby.html#method-i-init_config","(options={})",""],["init_config","NewRelic::Control::Frameworks::Sinatra","NewRelic/Control/Frameworks/Sinatra.html#method-i-init_config","(options={})",""],["init_plugin","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-init_plugin","(options={})","<p>Initialize the plugin/gem and start the agent.  This does the necessary\nconfiguration based on the framework …\n"],["initialize","Object","Object.html#method-i-initialize","(*args)",""],["initialize_with_new_relic","Object","Object.html#method-i-initialize_with_new_relic","(*args)",""],["initialize_without_new_relic","Object","Object.html#method-i-initialize_without_new_relic","(*args)",""],["inspect","NewRelic::MethodTraceStats","NewRelic/MethodTraceStats.html#method-i-inspect","()","<p>outputs a human-readable version of the MethodTraceStats object\n"],["inspect","NewRelic::MetricData","NewRelic/MetricData.html#method-i-inspect","()",""],["inspect","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-inspect","()",""],["install_browser_monitoring","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-install_browser_monitoring","(config)",""],["install_developer_mode","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-install_developer_mode","(rails_config)",""],["install_exit_handler","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-install_exit_handler","()","<p>Installs our exit handler, which exploits the weird behavior of at_exit\nblocks to make sure it runs last, …\n"],["install_instrumentation","NewRelic::Control::Instrumentation","NewRelic/Control/Instrumentation.html#method-i-install_instrumentation","()","<p>Signals the agent that it’s time to actually load the instrumentation\nfiles. May be overridden by subclasses …\n"],["install_shim","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-install_shim","()",""],["install_shim","NewRelic::Control::Instrumentation","NewRelic/Control/Instrumentation.html#method-i-install_shim","()","<p>Install stubs to the proper location so the app code will not fail if the\nagent is not running.\n"],["instance","NewRelic::Agent::Agent::ClassMethods","NewRelic/Agent/Agent/ClassMethods.html#method-i-instance","()","<p>Should only be called by NewRelic::Control - returns a memoized singleton\ninstance of the agent, creating …\n"],["instance","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-c-instance","()",""],["instance","NewRelic::Control::ClassMethods","NewRelic/Control/ClassMethods.html#method-i-instance","(create=true)","<p>Access the Control singleton, lazy initialized.  Default will instantiate a\nnew instance or pass false …\n"],["instrument_methods","NewRelic::Agent::Instrumentation::Memcache","NewRelic/Agent/Instrumentation/Memcache.html#method-i-instrument_methods","(the_class, method_names)",""],["is_execution_traced?","NewRelic::Agent","NewRelic/Agent.html#method-i-is_execution_traced-3F","()","<p>Check to see if we are capturing metrics currently on this thread.\n"],["is_reset?","NewRelic::Stats","NewRelic/Stats.html#method-i-is_reset-3F","()",""],["is_select?","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-is_select-3F","(statement)",""],["is_sql_recorded?","NewRelic::Agent","NewRelic/Agent.html#method-i-is_sql_recorded-3F","()","<p>helper method to check the thread local to determine whether sql is being\nrecorded or not\n"],["is_transaction_traced?","NewRelic::Agent","NewRelic/Agent.html#method-i-is_transaction_traced-3F","()","<p>helper method to check the thread local to determine whether the\ntransaction in progress is traced or …\n"],["is_web_transaction?","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-is_web_transaction-3F","(metric)",""],["javascript_header","NewRelic::Agent::BeaconConfiguration","NewRelic/Agent/BeaconConfiguration.html#method-i-javascript_header","()","<p>returns a copy of the static javascript header, in case people are munging\nstrings somewhere down the …\n"],["jruby_cpu_burn","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-jruby_cpu_burn","()",""],["keep_running","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-i-keep_running","()","<p>a simple accessor for @should_run\n"],["license_bytes","NewRelic::Agent::BeaconConfiguration","NewRelic/Agent/BeaconConfiguration.html#method-i-license_bytes","()","<p>returns a memoized version of the bytes in the license key for obscuring\ntransaction names in the javascript …\n"],["license_key","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-license_key","()",""],["load","NewRelic::LanguageSupport::DataSerialization","NewRelic/LanguageSupport/DataSerialization.html#method-c-load","(*args)",""],["load_data","NewRelic::Agent","NewRelic/Agent.html#method-i-load_data","()","<p>Note that only one transaction trace will be sent even if many are\nserialized, since the slowest is sent. …\n"],["load_framework_class","NewRelic::Control::ClassMethods","NewRelic/Control/ClassMethods.html#method-i-load_framework_class","(framework)","<p>Loads the specified framework class from the NewRelic::Control::Frameworks\nmodule\n"],["load_instrumentation_files","NewRelic::Control::Instrumentation","NewRelic/Control/Instrumentation.html#method-i-load_instrumentation_files","(pattern)","<p>Adds a list of files in Dir.glob format (e.g. ‘/app/foo  \n/*_instrumentation.rb’) This requires the files …\n"],["load_newrelic_yml","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-load_newrelic_yml","(path, binding)",""],["load_newrelic_yml","NewRelic::LanguageSupport::Control","NewRelic/LanguageSupport/Control.html#method-i-load_newrelic_yml","(*args)",""],["load_samplers","NewRelic::Control::Instrumentation","NewRelic/Control/Instrumentation.html#method-i-load_samplers","()","<p>adds samplers to the stats engine so that they run every minute. This is\ndynamically recognized by any …\n"],["load_test_framework","NewRelic::Control::ClassMethods","NewRelic/Control/ClassMethods.html#method-i-load_test_framework","()","<p>nb this does not ‘load test’ the framework, it loads the ‘test\nframework’\n"],["local_env","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-i-local_env","()",""],["local_env","NewRelic::Control::ClassMethods","NewRelic/Control/ClassMethods.html#method-i-local_env","()","<p>Access the LocalEnvironment singleton, lazy initialized\n"],["lock","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-i-lock","()","<p>returns a class-level memoized mutex to make sure we don’t run\noverlapping\n"],["locked_jobs","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-i-locked_jobs","()",""],["log","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-log","()","<p>Shorthand to the NewRelic::Agent.logger method\n"],["log","NewRelic::Agent::StatsEngine","NewRelic/Agent/StatsEngine.html#method-i-log","()",""],["log","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-i-log","()","<p>a helper to access the NewRelic::Control.instance.log\n"],["log","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-log","()","<p>returns either the log set up with setup_log or else a new logger pointing\nto standard out, if we’re …\n"],["log!","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-log-21","(msg, level=:info)",""],["log!","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-log-21","(msg, level=:info)",""],["log!","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-log-21","(msg, level=:info)","<p>send the given message to STDOUT so that it shows up in the console.  This\nshould be used for important …\n"],["log_app_names","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-log_app_names","()","<p>Logs the configured application names\n"],["log_connection!","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-log_connection-21","(config_data)","<p>Logs when we connect to the server, for debugging purposes\n<p>makes sure we know if an agent has not connected …\n\n"],["log_dispatcher","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-log_dispatcher","()","<p>Logs the dispatcher to the log file to assist with debugging. When no\ndebugger is present, logs this …\n"],["log_error","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-log_error","(error)","<p>When we have a problem connecting to the server, we need to tell the user\nwhat happened, since this is …\n"],["log_errors","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-log_errors","(code_area, metric)","<p>helper for logging errors to the newrelic_agent.log properly. Logs the\nerror at error level, and includes …\n"],["log_file_name","NewRelic::Control","NewRelic/Control.html#method-i-log_file_name","()","\n<pre>Retrieves the log file's name from the config file option</pre>\n<p>‘log_file_name’, defaulting to ‘newrelic_agent.log …\n"],["log_file_path","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-log_file_path","()",""],["log_if","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-log_if","(boolean, level, message)","<p>A helper method that logs a condition if that condition is true. Mentally\ncleaner than having every method …\n"],["log_path","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-log_path","()","<p>Sets up and caches the log path, attempting to create it if it does not\nexist.  If it does not succeed, …\n"],["log_seed_token","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-log_seed_token","()","<p>If we are using a seed and token to validate the agent, we should debug log\nthat fact so that debug logs …\n"],["log_sql_transmission_warning?","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-log_sql_transmission_warning-3F","()","<p>Warn the user when we are sending raw sql across the wire\n<p>they should probably be using ssl when this …\n\n"],["log_to_stdout?","NewRelic::Control","NewRelic/Control.html#method-i-log_to_stdout-3F","()",""],["log_underflow","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-log_underflow","()",""],["log_unless","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-log_unless","(boolean, level, message)","<p>A helper method that logs a condition unless that condition is true.\nMentally cleaner than having every …\n"],["log_version_and_pid","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-log_version_and_pid","()","<p>Classy logging of the agent version and the current pid, so we can\ndisambiguate processes in the log …\n"],["log_with_newrelic_instrumentation","NewRelic::Agent::Instrumentation::ActiveRecordInstrumentation","NewRelic/Agent/Instrumentation/ActiveRecordInstrumentation.html#method-i-log_with_newrelic_instrumentation","(sql, name, &block)",""],["log_with_newrelic_instrumentation","NewRelic::Agent::Instrumentation::DataMapperInstrumentation","NewRelic/Agent/Instrumentation/DataMapperInstrumentation.html#method-i-log_with_newrelic_instrumentation","(msg)","<p>Unlike in AR, log is called in DM after the query actually ran, complete\nwith metrics.  Since DO has …\n"],["log_worker_loop_start","NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread","NewRelic/Agent/Agent/InstanceMethods/StartWorkerThread.html#method-i-log_worker_loop_start","()","<p>logs info about the worker loop so users can see when the agent actually\nbegins running in the background …\n"],["logger","NewRelic::Agent","NewRelic/Agent.html#method-i-logger","()","<p>Get the logger for the agent.  Available after the agent has initialized.\nThis sends output to the agent …\n"],["logger","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-logger","()",""],["logger","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-logger","()",""],["lookup_stats","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-lookup_stats","(metric_name, scope_name = '')","<p>Returns a stat if one exists, otherwise returns nil. If you want\nauto-initialization, use one of get_stats …\n"],["main_stat","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-main_stat","(metric, options)","<p>the main statistic we should record in #trace_execution_scoped - a scoped\nmetric provided by the first …\n"],["major_version","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-major_version","()",""],["manual_start","NewRelic::Agent","NewRelic/Agent.html#method-i-manual_start","(options={})","<p>Call this to manually start the Agent in situations where the Agent does\nnot auto-start.\n<p>When the app …\n"],["memcache_key_snippet","NewRelic::Agent::Instrumentation::Memcache","NewRelic/Agent/Instrumentation/Memcache.html#method-i-memcache_key_snippet","(method_name)",""],["merge","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-merge","(sql_traces)",""],["merge","NewRelic::Stats","NewRelic/Stats.html#method-i-merge","(other_stats)",""],["merge!","NewRelic::Stats","NewRelic/Stats.html#method-i-merge-21","(other_stats)",""],["merge_attributes","NewRelic::Stats","NewRelic/Stats.html#method-i-merge_attributes","(other)",""],["merge_data","NewRelic::Agent::StatsEngine::MetricStats::Harvest","NewRelic/Agent/StatsEngine/MetricStats/Harvest.html#method-i-merge_data","(metric_data_hash)","<p>merge data from previous harvests into this stats engine - takes into\naccount the case where there are …\n"],["merge_data_from","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-merge_data_from","(data)","<p>Accepts data as provided by the serialize method and merges it into our\ncurrent collection of data to …\n"],["merge_data_from","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-merge_data_from","(*args;)",""],["merge_defaults","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-merge_defaults","(settings_hash)",""],["merge_options","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-merge_options","(options, hash=self)","<p>Merge the given options into the config options. They might be a nested\nhash\n"],["merge_server_side_config","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-merge_server_side_config","(data)",""],["method_with_push_scope","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-method_with_push_scope","(method_name, metric_name_code, options)","<p>returns an eval-able string that contains the tracing code for a fully\ntraced metric including scoping …\n"],["method_without_push_scope","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-method_without_push_scope","(method_name, metric_name_code, options)","<p>returns an eval-able string that contains the traced method code used if\nthe agent is not creating a …\n"],["metric_name","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-metric_name","()",""],["metric_spec=","NewRelic::MetricData","NewRelic/MetricData.html#method-i-metric_spec-3D","(new_spec)","<p>assigns a new metric spec, and retains the old metric spec as\n@original_spec if it exists currently\n"],["metrics","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-metrics","()","<p>Returns all of the metric names of all the stats in the engine\n"],["midpoint","NewRelic::Stats","NewRelic/Stats.html#method-i-midpoint","()",""],["min_time_less?","NewRelic::Stats","NewRelic/Stats.html#method-i-min_time_less-3F","(other)",""],["minor_version","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-minor_version","()",""],["mongrel","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-mongrel","()","<p>Sets the @mongrel instance variable if we can find a Mongrel::HttpServer\n"],["monitor_mode?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-monitor_mode-3F","()","<p>True if we are sending data to the server, monitoring production\n"],["monitoring?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-monitoring-3F","()","<p>Warn the user if they have configured their agent not to send data, that\nway we can see this clearly …\n"],["multi_threaded?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-multi_threaded-3F","()",""],["multiply_by","NewRelic::Stats","NewRelic/Stats.html#method-i-multiply_by","(percentage)","<p>multiply the total time and rate by the given percentage\n"],["need_to_explain?","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-need_to_explain-3F","()",""],["need_to_obfuscate?","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-need_to_obfuscate-3F","()",""],["new","NewRelic::Agent::Agent","NewRelic/Agent/Agent.html#method-c-new","()","<p>14105: v8 (tag 2.10.3) (no v7) 10379: v6 (not tagged) 4078:  v5 (tag 2.5.4)\n2292:  v4 (tag 2.3.6) 1754: …\n"],["new","NewRelic::Agent::BeaconConfiguration","NewRelic/Agent/BeaconConfiguration.html#method-c-new","(connect_data)","<p>Creates a new browser configuration data. Argument is a hash of\nconfiguration values from the server …\n"],["new","NewRelic::Agent::BrowserMonitoring::DummyMetricFrame","NewRelic/Agent/BrowserMonitoring/DummyMetricFrame.html#method-c-new","()",""],["new","NewRelic::Agent::Database::Obfuscator","NewRelic/Agent/Database/Obfuscator.html#method-c-new","()",""],["new","NewRelic::Agent::ErrorCollector","NewRelic/Agent/ErrorCollector.html#method-c-new","()","<p>Returns a new error collector\n"],["new","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-new","()",""],["new","NewRelic::Agent::Sampler","NewRelic/Agent/Sampler.html#method-c-new","(id)",""],["new","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-c-new","()",""],["new","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-c-new","()",""],["new","NewRelic::Agent::Samplers::MemorySampler","NewRelic/Agent/Samplers/MemorySampler.html#method-c-new","()",""],["new","NewRelic::Agent::Samplers::MemorySampler::ShellPS","NewRelic/Agent/Samplers/MemorySampler/ShellPS.html#method-c-new","(command)",""],["new","NewRelic::Agent::Samplers::ObjectSampler","NewRelic/Agent/Samplers/ObjectSampler.html#method-c-new","()",""],["new","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-c-new","()",""],["new","NewRelic::Agent::SlowSql","NewRelic/Agent/SlowSql.html#method-c-new","(sql, metric_name, config, duration, backtrace = nil)",""],["new","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-c-new","()",""],["new","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-c-new","(normalized_query, slow_sql, path, uri)",""],["new","NewRelic::Agent::StatsEngine","NewRelic/Agent/StatsEngine.html#method-c-new","()",""],["new","NewRelic::Agent::StatsEngine::GCProfiler::Profiler","NewRelic/Agent/StatsEngine/GCProfiler/Profiler.html#method-c-new","()",""],["new","NewRelic::Agent::StatsEngine::MetricStats::SynchronizedHash","NewRelic/Agent/StatsEngine/MetricStats/SynchronizedHash.html#method-c-new","()",""],["new","NewRelic::Agent::StatsEngine::ScopeStackElement","NewRelic/Agent/StatsEngine/ScopeStackElement.html#method-c-new","(name, deduct_call_time)",""],["new","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-c-new","()",""],["new","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-c-new","(time=Time.now)",""],["new","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-c-new","()",""],["new","NewRelic::Agent::TransactionSqlData","NewRelic/Agent/TransactionSqlData.html#method-c-new","()",""],["new","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-c-new","()",""],["new","NewRelic::ChainedCall","NewRelic/ChainedCall.html#method-c-new","(block1, block2)",""],["new","NewRelic::Command","NewRelic/Command.html#method-c-new","(command_line_args)",""],["new","NewRelic::Command::CommandFailure","NewRelic/Command/CommandFailure.html#method-c-new","(message, opt_parser=nil)",""],["new","NewRelic::Command::Deployments","NewRelic/Command/Deployments.html#method-c-new","(command_line_args)","<p>Initialize the deployment uploader with command line args. Use -h to see\noptions. When command_line_args …\n"],["new","NewRelic::Command::Install","NewRelic/Command/Install.html#method-c-new","(command_line_args={})",""],["new","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-c-new","(local_env, config_file_override=nil)","<p>initializes the control instance with a local environment and an optional\nconfig file override. Checks …\n"],["new","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-c-new","()",""],["new","NewRelic::MetricData","NewRelic/MetricData.html#method-c-new","(metric_spec, stats, metric_id)",""],["new","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-c-new","(metric_name = '', metric_scope = '')","<p>Need a “zero-arg” constructor so it can be instantiated from java\n(using jruby) for sending …\n"],["new","NewRelic::NoticedError","NewRelic/NoticedError.html#method-c-new","(path, data, exception, timestamp = Time.now)",""],["new","NewRelic::Rack::BrowserMonitoring","NewRelic/Rack/BrowserMonitoring.html#method-c-new","(app, options = {})",""],["new","NewRelic::Rack::DeveloperMode","NewRelic/Rack/DeveloperMode.html#method-c-new","(app)",""],["new","NewRelic::ScopedMethodTraceStats","NewRelic/ScopedMethodTraceStats.html#method-c-new","(unscoped_stats)",""],["new","NewRelic::StatsBase","NewRelic/StatsBase.html#method-c-new","()",""],["new","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-c-new","(metric_name, sample)",""],["new","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-c-new","(time = Time.now.to_f, sample_id = nil)",""],["new","NewRelic::TransactionSample::CompositeSegment","NewRelic/TransactionSample/CompositeSegment.html#method-c-new","(segments)",""],["new","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-c-new","(timestamp, metric_name, segment_id)",""],["new","NewRelic::TransactionSample::SummarySegment","NewRelic/TransactionSample/SummarySegment.html#method-c-new","(segment)",""],["new","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-c-new","(version_string)",""],["new_instance","NewRelic::Control::ClassMethods","NewRelic/Control/ClassMethods.html#method-i-new_instance","()","<p>Create the concrete class for environment specific behavior\n"],["newrelic_ignore","NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods","NewRelic/Agent/Instrumentation/ControllerInstrumentation/ClassMethods.html#method-i-newrelic_ignore","(specifiers={})","<p>Have NewRelic ignore actions in this controller.  Specify the actions as\nhash options using :except and …\n"],["newrelic_ignore_apdex","NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods","NewRelic/Agent/Instrumentation/ControllerInstrumentation/ClassMethods.html#method-i-newrelic_ignore_apdex","(specifiers={})","<p>Have NewRelic omit apdex measurements on the given actions.  Typically used\nfor actions that are not …\n"],["newrelic_method_exists?","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-newrelic_method_exists-3F","(method_name)","<p>Checks to see if the method we are attempting to trace actually exists or\nnot. #add_method_tracer can’t …\n"],["newrelic_metric_path","NewRelic::Agent::Instrumentation::Rails3::ActionController","NewRelic/Agent/Instrumentation/Rails3/ActionController.html#method-i-newrelic_metric_path","(action_name_override = nil)","<p>determine the path that is used in the metric name for the called\ncontroller action\n"],["newrelic_metric_path","Object","Object.html#method-i-newrelic_metric_path","()","<p>determine the path that is used in the metric name for the called\ncontroller action\n"],["newrelic_notice_error","NewRelic::Agent::Instrumentation::Rails3::Errors","NewRelic/Agent/Instrumentation/Rails3/Errors.html#method-i-newrelic_notice_error","(exception, custom_params = {})",""],["newrelic_notice_error","Object","Object.html#method-i-newrelic_notice_error","(exception, custom_params = {})","<p>Make a note of an exception associated with the currently executing\ncontroller action.  Note that this …\n"],["newrelic_request_headers","NewRelic::Agent::Instrumentation::ControllerInstrumentation","NewRelic/Agent/Instrumentation/ControllerInstrumentation.html#method-i-newrelic_request_headers","()",""],["newrelic_request_headers","NewRelic::Agent::Instrumentation::Rack","NewRelic/Agent/Instrumentation/Rack.html#method-i-newrelic_request_headers","()",""],["newrelic_response_code","NewRelic::Agent::Instrumentation::ControllerInstrumentation","NewRelic/Agent/Instrumentation/ControllerInstrumentation.html#method-i-newrelic_response_code","()","<p>Should be implemented in the dispatcher class\n"],["newrelic_root","NewRelic::Control::ClassMethods","NewRelic/Control/ClassMethods.html#method-i-newrelic_root","()","<p>The root directory for the plugin or gem\n"],["newrelic_root","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-newrelic_root","()","<p>Delegates to the class method newrelic_root, implemented by each subclass\n"],["normal_cpu_burn","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-normal_cpu_burn","()",""],["normalize","NewRelic::Agent::SlowSql","NewRelic/Agent/SlowSql.html#method-i-normalize","()",""],["normalize_params","NewRelic::CollectionHelper","NewRelic/CollectionHelper.html#method-i-normalize_params","(params)","<p>Transform parameter hash into a hash whose values are strictly strings\n"],["normalized_request_and_custom_params","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-normalized_request_and_custom_params","(options)","<p>normalizes the request and custom parameters before attaching them to the\nerror. See NewRelic::CollectionHelper#normalize_params …\n"],["notice_error","NewRelic::Agent","NewRelic/Agent.html#method-i-notice_error","(exception, options={})","<p>Record the given error.  It will be passed through the #ignore_error_filter\nif there is one.\n<p><code>exception</code> …\n\n"],["notice_error","NewRelic::Agent::ErrorCollector","NewRelic/Agent/ErrorCollector.html#method-i-notice_error","(exception, options={})","<p>Notice the error with the given available options:\n<p><code>:uri</code> =&gt; The request path, minus any request params …\n"],["notice_error","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-notice_error","(e, options={})","<p>If we have an active metric frame, notice the error and increment the error\nmetric. Options:\n<p><code>:request</code> …\n"],["notice_first_scope_push","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-notice_first_scope_push","(time)",""],["notice_first_scope_push","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_first_scope_push","(time)","<p>Creates a new transaction sample builder, unless the transaction sampler is\ndisabled. Takes a time parameter …\n"],["notice_nosql","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_nosql","(key, duration)","<p>Adds non-sql metadata to a segment - generally the memcached key\n<p>duration is seconds, float value.\n"],["notice_pop_scope","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_pop_scope","(scope, time = Time.now)","<p>Informs the transaction sample builder about the end of a traced scope\n"],["notice_profile","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_profile","(profile)","<p>For developer mode profiling support - delegates to the builder\n"],["notice_push_scope","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_push_scope","(scope, time=Time.now)","<p>This delegates to the builder to create a new open transaction segment for\nthe specified scope, beginning …\n"],["notice_scope_empty","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-notice_scope_empty","()",""],["notice_scope_empty","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-notice_scope_empty","(time=Time.now)","<p>This is called when we are done with the transaction.\n"],["notice_scope_empty","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_scope_empty","(time=Time.now)","<p>This is called when we are done with the transaction.  We’ve unwound the\nstack to the top level. It also …\n"],["notice_sql","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-notice_sql","(sql, metric_name, config, duration)",""],["notice_sql","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_sql","(sql, config, duration)","<p>some statements (particularly INSERTS with large BLOBS may be very large;\nwe should trim them to a maximum …\n"],["notice_transaction","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-notice_transaction","(path, uri=nil, params={})",""],["notice_transaction","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_transaction","(path, uri=nil, params={})","<p>Delegates to the builder to store the path, uri, and parameters if the\nsampler is active\n"],["notice_transaction_cpu_time","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-notice_transaction_cpu_time","(cpu_time)","<p>Sets the CPU time used by a transaction, delegates to the builder\n"],["notify_log_file_location","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-notify_log_file_location","()","<p>Tells us in the log file where the log file is located. This seems\nredundant, but can come in handy when …\n"],["notify_transaction_sampler","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-notify_transaction_sampler","(web_transaction)",""],["obfuscate","NewRelic::Agent::SlowSql","NewRelic/Agent/SlowSql.html#method-i-obfuscate","()",""],["obfuscate_sql","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-obfuscate_sql","(sql)",""],["obfuscated_sql","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-obfuscated_sql","()",""],["omit_segments_with","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-omit_segments_with","(regex)","<p>return a new transaction sample that treats segments with the given regular\nexpression in their name …\n"],["original_spec","NewRelic::MetricData","NewRelic/MetricData.html#method-i-original_spec","()",""],["over_queue_limit?","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-over_queue_limit-3F","(message)","<p>checks the size of the error queue to make sure we are under the maximum\nlimit, and logs a warning if …\n"],["params","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-params","()",""],["params=","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-params-3D","(params)",""],["params=","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-params-3D","(p)",""],["parent_segment=","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-parent_segment-3D","(s)",""],["parse_frontend_headers","NewRelic::Agent::Instrumentation::QueueTime","NewRelic/Agent/Instrumentation/QueueTime.html#method-i-parse_frontend_headers","(headers)",""],["parse_query_with_newrelic","NewRelic::Instrumentation::ActsAsSolrInstrumentation::ParserMethodsInstrumentation","NewRelic/Instrumentation/ActsAsSolrInstrumentation/ParserMethodsInstrumentation.html#method-i-parse_query_with_newrelic","(*args)",""],["path","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-path","()","<p>Return the path, the part of the metric after the category\n"],["path_string","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-path_string","()",""],["path_string","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-path_string","()",""],["peek_scope","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-peek_scope","()","<p>Returns the latest ScopeStackElement\n"],["perform_action_with_newrelic_trace","NewRelic::Agent::Instrumentation::ControllerInstrumentation","NewRelic/Agent/Instrumentation/ControllerInstrumentation.html#method-i-perform_action_with_newrelic_trace","(*args, &block)","<p>Yield to the given block with NewRelic tracing.  Used by default\ninstrumentation on controller actions …\n"],["pid_too_old?","NewRelic::DataSerialization::ClassMethods","NewRelic/DataSerialization/ClassMethods.html#method-i-pid_too_old-3F","()",""],["platform","NewRelic::Agent::Samplers::MemorySampler","NewRelic/Agent/Samplers/MemorySampler.html#method-c-platform","()",""],["platform","NewRelic::Agent::Samplers::MemorySampler","NewRelic/Agent/Samplers/MemorySampler.html#method-i-platform","()",""],["poll","NewRelic::Agent::Sampler","NewRelic/Agent/Sampler.html#method-i-poll","()",""],["poll","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-i-poll","()",""],["poll","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-i-poll","()",""],["poll","NewRelic::Agent::Samplers::MemorySampler","NewRelic/Agent/Samplers/MemorySampler.html#method-i-poll","()",""],["poll","NewRelic::Agent::Samplers::ObjectSampler","NewRelic/Agent/Samplers/ObjectSampler.html#method-i-poll","()",""],["pop","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-pop","()","<p>Unwind one stack level.  It knows if it’s back at the outermost caller\nand does the appropriate wrapup …\n"],["pop_flag!","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-pop_flag-21","(forced)","<p>delegates to #agent_instance to pop the trace execution flag, only if\nexecution of this metric is forced. …\n"],["pop_scope","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-pop_scope","(expected_scope, duration, time=Time.now.to_f)","<p>Pops a scope off the transaction stack - this updates the transaction\nsampler that we’ve finished execution …\n"],["pop_trace_execution_flag","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-pop_trace_execution_flag","()","<p>Pop the current trace execution status.  Restore trace execution status to\nwhat it was before we pushed …\n"],["pop_trace_execution_flag","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-pop_trace_execution_flag","(*args;)",""],["post_size_limit","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-post_size_limit","()","<p>defaults to 2MiB\n"],["prepare_to_send","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-prepare_to_send","()",""],["prepare_to_send","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-prepare_to_send","(options={})","<p>Return a new transaction sample that can be sent to the New Relic service.\nThis involves potentially …\n"],["proc_status_file","NewRelic::Agent::Samplers::MemorySampler::ProcStatus","NewRelic/Agent/Samplers/MemorySampler/ProcStatus.html#method-i-proc_status_file","()",""],["process_action","NewRelic::Agent::Instrumentation::Rails3::ActionController","NewRelic/Agent/Instrumentation/Rails3/ActionController.html#method-i-process_action","(*args)",""],["process_resultset","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-process_resultset","(items)",""],["profiling=","NewRelic::Control::Profiling","NewRelic/Control/Profiling.html#method-i-profiling-3D","(val)","<p>Set the flag for capturing profiles in dev mode.  If RubyProf is not loaded\na true value is ignored. …\n"],["profiling?","NewRelic::Control::Profiling","NewRelic/Control/Profiling.html#method-i-profiling-3F","()","<p>A flag used in dev mode to indicate if profiling is available\n"],["profiling_available?","NewRelic::Control::Profiling","NewRelic/Control/Profiling.html#method-i-profiling_available-3F","()",""],["proxy_server","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-proxy_server","()","<p>a new instances of the proxy server - this passes through if there is no\nproxy, otherwise it has proxy …\n"],["push","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-push","(m)","<p>Indicate that we are entering a measured controller action or task. Make\nsure you unwind every push with …\n"],["push_flag!","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-push_flag-21","(forced)","<p>delegates to #agent_instance to push a trace execution flag, only if\nexecution of this metric is forced. …\n"],["push_scope","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-push_scope","(metric, time = Time.now.to_f, deduct_call_time_from_parent = true)","<p>Pushes a scope onto the transaction stack - this generates a\nTransactionSample::Segment at the end of …\n"],["push_trace_execution_flag","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-push_trace_execution_flag","(should_trace=false)","<p>Push flag indicating whether we should be tracing in this thread. This uses\na stack which allows us to …\n"],["push_trace_execution_flag","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-push_trace_execution_flag","(*args;)",""],["query_server_for_configuration","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-query_server_for_configuration","()","<p>Sets the collector host and connects to the server, then invokes the final\nconfiguration with the returned …\n"],["queue_time","NewRelic::Agent::BrowserMonitoring::DummyMetricFrame","NewRelic/Agent/BrowserMonitoring/DummyMetricFrame.html#method-i-queue_time","()",""],["queue_time","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-queue_time","()",""],["rails_gem_list","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-rails_gem_list","()",""],["rails_vendor_root","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-rails_vendor_root","()",""],["rails_version","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-rails_version","()",""],["read_and_write_to_file","NewRelic::DataSerialization::ClassMethods","NewRelic/DataSerialization/ClassMethods.html#method-i-read_and_write_to_file","()","<p>A combined locked read/write from the store file - reduces contention by\nnot acquiring the lock and file …\n"],["record_apdex","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-record_apdex","(current_metric, action_duration, total_duration, is_error)",""],["record_apdex","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-record_apdex","()",""],["record_apdex_f","NewRelic::ApdexStats","NewRelic/ApdexStats.html#method-i-record_apdex_f","()",""],["record_apdex_s","NewRelic::ApdexStats","NewRelic/ApdexStats.html#method-i-record_apdex_s","()",""],["record_apdex_t","NewRelic::ApdexStats","NewRelic/ApdexStats.html#method-i-record_apdex_t","()",""],["record_data_point","NewRelic::MethodTraceStats","NewRelic/MethodTraceStats.html#method-i-record_data_point","(value, exclusive_time = value)","<p>record a single data point into the statistical gatherer.  The gatherer\nwill aggregate all data points …\n"],["record_gc_metric","NewRelic::Agent::StatsEngine::GCProfiler::Profiler","NewRelic/Agent/StatsEngine/GCProfiler/Profiler.html#method-i-record_gc_metric","(num_calls, elapsed)",""],["record_jruby_cpu_burn","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-record_jruby_cpu_burn","(burn)","<p>we need to do this here because the normal cpu sampler process doesn’t\nwork on JRuby. See the cpu_sampler.rb …\n"],["record_multiple_data_points","NewRelic::MethodTraceStats","NewRelic/MethodTraceStats.html#method-i-record_multiple_data_points","(total_value, count=1)","<p>Records multiple data points as one method call - this handles all the\naggregation that would be done …\n"],["record_multiple_data_points","NewRelic::ScopedMethodTraceStats","NewRelic/ScopedMethodTraceStats.html#method-i-record_multiple_data_points","(total_value, count=1)","<p>Records multiple data points as one method call - this handles all the\naggregation that would be done …\n"],["record_transaction","NewRelic::Agent","NewRelic/Agent.html#method-i-record_transaction","(response_sec, options = {})","<p>Record a web transaction from an external source.  This will process the\nresponse time, error, and score …\n"],["record_transaction","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-record_transaction","(duration_seconds, options={})","<p>fakes out a transaction that did not happen in this process by creating\napdex, summary metrics, and recording …\n"],["record_transaction_cpu","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-record_transaction_cpu","()",""],["recorded_metrics","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-recorded_metrics","()","<p>Return the array of metrics to record for the current metric frame.\n"],["recording_web_transaction?","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-recording_web_transaction-3F","()",""],["recording_web_transaction?","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-recording_web_transaction-3F","()",""],["referer","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-referer","()",""],["referer","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-referer","()","<p>For the current web transaction, return the full referer, minus the host\nstring, or nil.\n"],["referer_from_request","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-referer_from_request","(request)","<p>Make a safe attempt to get the referer from a request object, generally\nsuccessful when it’s a Rack request. …\n"],["remove_server_controlled_configs","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-remove_server_controlled_configs","()",""],["remove_transaction_sampler","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-remove_transaction_sampler","(l)","<p>removes a transaction sampler\n"],["render_collection","ActionView::Partials::PartialRenderer","ActionView/Partials/PartialRenderer.html#method-i-render_collection","(*args)",""],["render_partial","ActionView::Partials::PartialRenderer","ActionView/Partials/PartialRenderer.html#method-i-render_partial","(*args)",""],["render_time","NewRelic::TransactionAnalysis","NewRelic/TransactionAnalysis.html#method-i-render_time","()",""],["request","Object","Object.html#method-i-request","(*args, &block)",""],["request_params_from_opts","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-request_params_from_opts","(options)","<p>takes the request parameters out of the options hash, and returns them if\nwe are capturing parameters, …\n"],["request_with_newrelic_trace","Object","Object.html#method-i-request_with_newrelic_trace","(*args, &block)",""],["request_without_newrelic_trace","Object","Object.html#method-i-request_without_newrelic_trace","(*args, &block)",""],["requests_per_minute","NewRelic::Stats","NewRelic/Stats.html#method-i-requests_per_minute","()",""],["rescue_action_with_newrelic_trace","Object","Object.html#method-i-rescue_action_with_newrelic_trace","(exception)",""],["reset","NewRelic::Agent::BusyCalculator","NewRelic/Agent/BusyCalculator.html#method-i-reset","()","<p>Reset the state of the information accumulated by all threads, but only\nreset the recursion counter for …\n"],["reset","NewRelic::Agent::Database::Obfuscator","NewRelic/Agent/Database/Obfuscator.html#method-i-reset","()",""],["reset","NewRelic::Agent::StatsEngine::GCProfiler::Profiler","NewRelic/Agent/StatsEngine/GCProfiler/Profiler.html#method-i-reset","()",""],["reset","NewRelic::Agent::StatsEngine::GCProfiler::Ruby19","NewRelic/Agent/StatsEngine/GCProfiler/Ruby19.html#method-i-reset","()",""],["reset","NewRelic::Stats","NewRelic/Stats.html#method-i-reset","()",""],["reset!","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-reset-21","()","<p>reset samples without rebooting the web server\n"],["reset!","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-reset-21","()","<p>reset samples without rebooting the web server\n"],["reset_stats","NewRelic::Agent","NewRelic/Agent.html#method-i-reset_stats","()","<p>Clear out any unsent metric data. See NewRelic::Agent::Agent#reset_stats\n"],["reset_stats","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-reset_stats","()","<p>Clear out the metric data, errors, and transaction traces, making sure the\nagent is in a fresh state …\n"],["reset_stats","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-reset_stats","()","<p>Reset each of the stats, such as when a new passenger instance starts up.\n"],["resolve_ip_address","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-resolve_ip_address","(host)","<p>Look up the ip address of the host using the pure ruby lookup to prevent\nblocking.  If that fails, fall …\n"],["root","NewRelic::Control::Frameworks::Merb","NewRelic/Control/Frameworks/Merb.html#method-i-root","()",""],["root","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-root","()",""],["root","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-root","()","<p>Rails can return an empty string from this method, causing the agent not to\nstart even when it is properly …\n"],["root","NewRelic::Control::Frameworks::Ruby","NewRelic/Control/Frameworks/Ruby.html#method-i-root","()",""],["root","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-root","()",""],["route_eval_with_newrelic","NewRelic::Agent::Instrumentation::Sinatra","NewRelic/Agent/Instrumentation/Sinatra.html#method-i-route_eval_with_newrelic","(&block_arg)",""],["run","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-i-run","(period=nil, &block)","<p>Run infinitely, calling the registered tasks at their specified call\nperiods.  The caller is responsible …\n"],["run","NewRelic::Command","NewRelic/Command.html#method-c-run","()",""],["run","NewRelic::Command::Deployments","NewRelic/Command/Deployments.html#method-i-run","()","<p>Run the Deployment upload in New Relic via Active Resource. Will possibly\nprint errors and exit the  …\n"],["run","NewRelic::Command::Install","NewRelic/Command/Install.html#method-i-run","()",""],["run","NewRelic::MerbBootLoader","NewRelic/MerbBootLoader.html#method-c-run","()",""],["run_task","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-i-run_task","()","<p>Executes the block given to the worker loop, and handles many possible\nerrors. Also updates the execution …\n"],["sample_id","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-sample_id","()",""],["sampler_classes","NewRelic::Agent::Sampler","NewRelic/Agent/Sampler.html#method-c-sampler_classes","()",""],["sampling_rate=","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-sampling_rate-3D","(val)","<p>Set with an integer value n, this takes one in every n harvested samples.\nIt also resets the harvest …\n"],["save_data","NewRelic::Agent","NewRelic/Agent.html#method-i-save_data","()","<p>a method used to serialize short-running processes to disk, so we don’t\nincur the overhead of reporting …\n"],["scope_depth","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-scope_depth","()",""],["scope_depth","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-scope_depth","()","<p>Defaults to zero, otherwise delegated to the transaction sample builder\n"],["scope_name","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-scope_name","()","<p>Returns the current scope name from the thread local\n"],["scope_name=","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-scope_name-3D","(transaction)","<p>set the name of the transaction for the current thread, which will be used\nto define the scope of all …\n"],["scope_stack","NewRelic::Agent::StatsEngine::GCProfiler::Profiler","NewRelic/Agent/StatsEngine/GCProfiler/Profiler.html#method-i-scope_stack","()",""],["send_data_on_exit","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-send_data_on_exit","()","<p>Configuration option of the same name to indicate that we should flush data\nto the server on exiting. …\n"],["sense_method","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-sense_method","(object, method)","<p>calls a method on an object, if it responds to it - used for detection and\nsoft fail-safe. Returns nil …\n"],["serialize","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-serialize","()","<p>Serialize all the important data that the agent might want to send to the\nserver. We could be sending …\n"],["serialize","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-serialize","()",""],["server","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-server","()",""],["server_from_host","NewRelic::Control::ServerMethods","NewRelic/Control/ServerMethods.html#method-i-server_from_host","(hostname=nil)","<p>turns a hostname into an ip address and returns a NewRelic::Control::Server\nthat contains the configuration …\n"],["set","NewRelic::Agent::TransactionInfo","NewRelic/Agent/TransactionInfo.html#method-c-set","(instance)",""],["set_collector_host!","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-set_collector_host-21","()","<p>Asks the collector to tell us which sub-collector we should be reporting\nto, and then does the name resolution …\n"],["set_deduct_call_time_based_on_metric","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-set_deduct_call_time_based_on_metric","(options)","<p>Sets the options for deducting call time from parents. This defaults to\ntrue if we are recording a metric, …\n"],["set_if_nil","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-set_if_nil","(hash, key)","<p>Helper for setting a hash key if the hash key is nil, instead of the\ndefault ||= behavior which sets …\n"],["set_log_format!","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-set_log_format-21","(logger)","<p>patches the logger’s format_message method to change the format just for\nour logger\n"],["set_log_level!","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-set_log_level-21","(logger)","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">set</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">log</span> <span class=\"ruby-identifier\">level</span> <span class=\"ruby-identifier\">as</span> <span class=\"ruby-identifier\">specified</span> <span class=\"ruby-keyword\">in</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-identifier\">config</span> <span class=\"ruby-identifier\">file</span>\n\n<span class=\"ruby-constant\">Possible</span> <span class=\"ruby-identifier\">values</span> <span class=\"ruby-identifier\">are</span> <span class=\"ruby-identifier\">from</span> <span class=\"ruby-identifier\">the</span> <span class=\"ruby-constant\">Logger</span> <span class=\"ruby-keyword\">class</span><span class=\"ruby-operator\">:</span> <span class=\"ruby-identifier\">debug</span>, <span class=\"ruby-operator\">...</span>\n</pre>\n"],["set_new_scope!","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-set_new_scope-21","(metric)",""],["set_primary","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-set_primary","(slow_sql, path, uri)",""],["set_profile","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-set_profile","(profile)",""],["set_record_sql","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-set_record_sql","(should_record)","<p>Sets a thread local variable as to whether we should or should not record\nsql in the current thread. …\n"],["set_record_tt","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-set_record_tt","(should_record)","<p>Sets a thread local variable as to whether we should or should not record\ntransaction traces in the current …\n"],["set_sql_obfuscator","NewRelic::Agent","NewRelic/Agent.html#method-i-set_sql_obfuscator","(type = :replace, &block)","<p>This method sets the block sent to this method as a sql obfuscator.  The\nblock will be called with a …\n"],["set_sql_obfuscator","NewRelic::Agent::Database","NewRelic/Agent/Database.html#method-i-set_sql_obfuscator","(type, &block)",""],["set_sql_obfuscator","NewRelic::Agent::Database::Obfuscator","NewRelic/Agent/Database/Obfuscator.html#method-i-set_sql_obfuscator","(type, &block)","<p>Sets the sql obfuscator used to clean up sql when sending it to the server.\nPossible types are:\n<p>:before …\n"],["set_sql_recording!","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-set_sql_recording-21","()","<p>Sets the sql recording configuration by trying to detect any attempt to\ndisable the sql collection - …\n"],["set_transaction_cpu_time","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-set_transaction_cpu_time","(cpu_time)",""],["set_transaction_info","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-set_transaction_info","(path, uri, params)",""],["set_transaction_info","NewRelic::Agent::TransactionSqlData","NewRelic/Agent/TransactionSqlData.html#method-i-set_transaction_info","(path, uri, params, guid)",""],["set_user_attributes","NewRelic::Agent","NewRelic/Agent.html#method-i-set_user_attributes","(attributes)","<p>Set attributes about the user making this request. These attributes will be\nautomatically appended to …\n"],["set_user_attributes","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-set_user_attributes","(attributes)",""],["set_user_attributes","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-set_user_attributes","(attributes)",""],["settings","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-settings","()",""],["setup_log","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-setup_log","()","<p>Create the logger using the configuration variables\n<p>Control subclasses may override this, but it can be …\n"],["should_exit_notice_error?","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-should_exit_notice_error-3F","(exception)","<p>whether we should return early from the notice_error process\n<p>based on whether the error is ignored or …\n\n"],["should_instrument?","NewRelic::Rack::BrowserMonitoring","NewRelic/Rack/BrowserMonitoring.html#method-i-should_instrument-3F","(status, headers)",""],["should_keep_retrying?","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-should_keep_retrying-3F","(options)","<p>We keep trying by default, but you can disable it with the :keep_retrying\noption set to false\n"],["should_log?","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-should_log-3F","()","<p>true if the agent has settings, and the agent is enabled, otherwise false\n"],["should_replace_begin_time?","NewRelic::Stats","NewRelic/Stats.html#method-i-should_replace_begin_time-3F","(other)",""],["should_replace_end_time?","NewRelic::Stats","NewRelic/Stats.html#method-i-should_replace_end_time-3F","(other)",""],["should_retry?","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-should_retry-3F","()","<p>We should only retry when there has not been a more serious condition that\nwould prevent it. We increment …\n"],["should_send_data?","NewRelic::DataSerialization::ClassMethods","NewRelic/DataSerialization/ClassMethods.html#method-i-should_send_data-3F","()","<p>Check whether the store is too large, too old, or the pid file is too old.\nIf so, we should send the …\n"],["shutdown","NewRelic::Agent","NewRelic/Agent.html#method-i-shutdown","(options={})","<p>Shutdown the agent.  Call this before exiting.  Sends any queued data and\nkills the background thread. …\n"],["shutdown","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-shutdown","(options={})","<p>Attempt a graceful shutdown of the agent, running the worker loop if it\nexists and is running.\n<p>Options: …\n"],["shutdown","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-shutdown","(*args;)",""],["slowest_sample?","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-slowest_sample-3F","(old_sample, new_sample)","<p>Checks to see if the old sample exists, or if it’s duration is less than\nthe new sample\n"],["snapshot","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-snapshot","()","<p>Take a snapshot of the environment information for this application Returns\nan associative array\n"],["split","NewRelic::Stats","NewRelic/Stats.html#method-i-split","(rollup_begin_time, rollup_period)","<p>split into an array of timeslices whose time boundaries start on\n(begin_time + (n * duration)) and whose …\n"],["sql_segments","NewRelic::TransactionAnalysis","NewRelic/TransactionAnalysis.html#method-i-sql_segments","(show_non_sql_segments = true)","<p>return an array of sql statements executed by this transaction each element\nin the array contains [sql, …\n"],["stack_min_max_from","NewRelic::Stats","NewRelic/Stats.html#method-i-stack_min_max_from","(other)",""],["standard_deviation","NewRelic::Stats","NewRelic/Stats.html#method-i-standard_deviation","()",""],["start","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-start","()","<p>Logs a bunch of data and starts the agent, if needed\n"],["start","NewRelic::Agent::ShimAgent","NewRelic/Agent/ShimAgent.html#method-i-start","(*args;)",""],["start_agent","NewRelic::Control::InstanceMethods","NewRelic/Control/InstanceMethods.html#method-i-start_agent","()","<p>Install the real agent into the Agent module, and issue the start command.\n"],["start_builder","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-start_builder","(time=nil)","<p>Checks to see if the transaction sampler is disabled, if transaction trace\nrecording is disabled by a …\n"],["start_sampler_thread","NewRelic::Agent::StatsEngine::Samplers","NewRelic/Agent/StatsEngine/Samplers.html#method-i-start_sampler_thread","()","<p>starts the sampler thread which runs periodically, rather than at harvest\ntime. This is deprecated, and …\n"],["start_time","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-start_time","()",""],["start_transaction","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-start_transaction","()","<p>Tells the statistics engine we are starting a new transaction\n"],["start_transaction","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-start_transaction","()","<p>This needs to be called after entering the call to trace the controller\naction, otherwise the controller …\n"],["start_transaction","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-start_transaction","(name = nil)","<p>Start a new transaction, unless one is already in progress\n"],["started?","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-started-3F","()","<p>True if we have initialized and completed ‘start’\n"],["stat_engine","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-stat_engine","()","<p>Shorthand to return the current statistics engine\n"],["stats","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-i-stats","()",""],["stats","NewRelic::Agent::Samplers::MemorySampler","NewRelic/Agent/Samplers/MemorySampler.html#method-i-stats","()",""],["stats","NewRelic::Agent::Samplers::ObjectSampler","NewRelic/Agent/Samplers/ObjectSampler.html#method-i-stats","()",""],["stats_hash","NewRelic::Agent::StatsEngine::MetricStats","NewRelic/Agent/StatsEngine/MetricStats.html#method-i-stats_hash","()","<p>returns a memoized SynchronizedHash that holds the actual instances of\nStats keyed off their MetricName …\n"],["stop","NewRelic::Agent::WorkerLoop","NewRelic/Agent/WorkerLoop.html#method-i-stop","()","<p>Sets @should_run to false. Returns false\n"],["store_force_persist","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-store_force_persist","(sample)",""],["store_random_sample","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-store_random_sample","(sample)","<p>Only active when random sampling is true - this is very rarely used. Always\nstore the most recent sample …\n"],["store_sample","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-store_sample","(sample)","<p>Samples can be stored in three places: the random sample variable, when\nrandom sampling is active, the …\n"],["store_sample_for_developer_mode","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-store_sample_for_developer_mode","(sample)","<p>Samples take up a ton of memory, so we only store a lot of them in\ndeveloper mode - we truncate to @ …\n"],["store_slowest_sample","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-store_slowest_sample","(sample)","<p>Sets @slowest_sample to the passed in sample if it is slower than the\ncurrent sample in @slowest_sample …\n"],["store_too_large?","NewRelic::DataSerialization::ClassMethods","NewRelic/DataSerialization/ClassMethods.html#method-i-store_too_large-3F","()",""],["store_too_old?","NewRelic::DataSerialization::ClassMethods","NewRelic/DataSerialization/ClassMethods.html#method-i-store_too_old-3F","()",""],["strip_nr_from_backtrace","NewRelic::CollectionHelper","NewRelic/CollectionHelper.html#method-i-strip_nr_from_backtrace","(backtrace)","<p>Return an array of strings (backtrace), cleaned up for readability Return\nnil if there is no backtrace …\n"],["sub","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-sub","(pattern, replacement, apply_to_scope = true)","<p>return a new metric spec if the given regex matches the name or scope.\n"],["sum_attributes","NewRelic::Stats","NewRelic/Stats.html#method-i-sum_attributes","(other)",""],["sum_merge!","NewRelic::Stats","NewRelic/Stats.html#method-i-sum_merge-21","(other_stats)","<p>merge by adding to average response time\n<p>used to compose multiple metrics e.g. dispatcher time + mongrel …\n\n"],["summary","NewRelic::Stats","NewRelic/Stats.html#method-i-summary","()","<p>Summary string to facilitate testing\n"],["supported_on_this_platform?","NewRelic::Agent::Sampler","NewRelic/Agent/Sampler.html#method-c-supported_on_this_platform-3F","()","<p>Override with check.  Called before instantiating.\n"],["supported_on_this_platform?","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-c-supported_on_this_platform-3F","()",""],["supported_on_this_platform?","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-c-supported_on_this_platform-3F","()",""],["supported_on_this_platform?","NewRelic::Agent::Samplers::MemorySampler","NewRelic/Agent/Samplers/MemorySampler.html#method-c-supported_on_this_platform-3F","()",""],["supported_on_this_platform?","NewRelic::Agent::Samplers::ObjectSampler","NewRelic/Agent/Samplers/ObjectSampler.html#method-c-supported_on_this_platform-3F","()",""],["sync_startup","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-sync_startup","()","<p>Configuration option of the same name to indicate that we should connect to\nNew Relic synchronously on …\n"],["system_util_stats","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-i-system_util_stats","()",""],["systemtime_stats","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-i-systemtime_stats","()",""],["time_percentage","NewRelic::Stats","NewRelic/Stats.html#method-i-time_percentage","()","<p>returns the time spent in this component as a percentage of the total time\nwindow.\n"],["time_str","NewRelic::Stats","NewRelic/Stats.html#method-i-time_str","(value_ms)","<p>outputs a useful human-readable time given a value in milliseconds\n"],["timestamp","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-timestamp","()","<p>offset from start of app\n"],["tiny_version","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-tiny_version","()",""],["to_debug_str","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-to_debug_str","(depth)",""],["to_json","NewRelic::Agent::SqlTrace","NewRelic/Agent/SqlTrace.html#method-i-to_json","(*a)",""],["to_json","NewRelic::MetricData","NewRelic/MetricData.html#method-i-to_json","(*a)","<p>Serialize with all attributes, but if the metric id is not nil, then\ndon’t send the metric spec\n"],["to_json","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-to_json","(*a)",""],["to_json","NewRelic::StatsBase","NewRelic/StatsBase.html#method-i-to_json","(*a)",""],["to_json","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-to_json","(options={})",""],["to_s","NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler","NewRelic/Agent/Samplers/MemorySampler/JavaHeapSampler.html#method-i-to_s","()",""],["to_s","NewRelic::Agent::Samplers::MemorySampler::ProcStatus","NewRelic/Agent/Samplers/MemorySampler/ProcStatus.html#method-i-to_s","()",""],["to_s","NewRelic::Agent::Samplers::MemorySampler::ShellPS","NewRelic/Agent/Samplers/MemorySampler/ShellPS.html#method-i-to_s","()",""],["to_s","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-to_s","()","<p>outputs a human-readable description\n"],["to_s","NewRelic::MetricData","NewRelic/MetricData.html#method-i-to_s","()",""],["to_s","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-to_s","()",""],["to_s","NewRelic::Stats","NewRelic/Stats.html#method-i-to_s","()",""],["to_s","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-to_s","()",""],["to_s","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-to_s","()",""],["to_s","NewRelic::VersionNumber","NewRelic/VersionNumber.html#method-i-to_s","()",""],["to_s_compact","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-to_s_compact","()",""],["to_s_compact","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-to_s_compact","()",""],["to_stdout","NewRelic::Control::Frameworks::Merb","NewRelic/Control/Frameworks/Merb.html#method-i-to_stdout","(msg)",""],["to_stdout","NewRelic::Control::Frameworks::Rails","NewRelic/Control/Frameworks/Rails.html#method-i-to_stdout","(message)",""],["to_stdout","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-to_stdout","(msg)",""],["to_stdout","NewRelic::Control::Frameworks::Ruby","NewRelic/Control/Frameworks/Ruby.html#method-i-to_stdout","(msg)",""],["to_stdout","NewRelic::Control::LoggingMethods","NewRelic/Control/LoggingMethods.html#method-i-to_stdout","(msg)","<p>simply puts a message to standard out, prepended with the ‘**\n[NewRelic]’ sigil to make sure people know …\n"],["total_call_time_per_minute","NewRelic::Stats","NewRelic/Stats.html#method-i-total_call_time_per_minute","()",""],["total_time_percentage","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-i-total_time_percentage","()",""],["trace_call","NewRelic::MethodTraceStats","NewRelic/MethodTraceStats.html#method-i-trace_call","(value, exclusive_time = value)",""],["trace_call","NewRelic::ScopedMethodTraceStats","NewRelic/ScopedMethodTraceStats.html#method-i-trace_call","(call_time, exclusive_time = call_time)",""],["trace_disabled?","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-trace_disabled-3F","(options)","<p>Tracing is disabled if we are not in a traced context and no force option\nis supplied\n"],["trace_entry","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-trace_entry","(metric_name, time)",""],["trace_execution_scoped","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-trace_execution_scoped","(metric_names, options={})","<p>Trace a given block with stats and keep track of the caller. See\nNewRelic::Agent::MethodTracer::ClassMethods#add_method_tracer …\n"],["trace_execution_scoped_footer","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-trace_execution_scoped_footer","(t0, first_name, metric_stats, expected_scope, forced, t1=Time.now.to_f)","<p>Handles the end of the #trace_execution_scoped method - calculating the\ntime taken, popping the tracing …\n"],["trace_execution_scoped_header","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-trace_execution_scoped_header","(metric, options, t0=Time.now.to_f)","<p>provides the header for our traced execution scoped method - gets the\ninitial time, sets the tracing …\n"],["trace_execution_unscoped","NewRelic::Agent::MethodTracer::InstanceMethods","NewRelic/Agent/MethodTracer/InstanceMethods.html#method-i-trace_execution_unscoped","(metric_names, options={})","<p>Trace a given block with stats assigned to the given metric_name.  It does\nnot provide scoped measurements, …\n"],["trace_exit","NewRelic::Agent::TransactionSampleBuilder","NewRelic/Agent/TransactionSampleBuilder.html#method-i-trace_exit","(metric_name, time)",""],["trace_method_execution_no_scope","NewRelic::Agent::MethodTracer::InstanceMethods","NewRelic/Agent/MethodTracer/InstanceMethods.html#method-i-trace_method_execution_no_scope","(metric_names, options={})",""],["traced?","NewRelic::Agent::Instrumentation::MetricFrame::Pop","NewRelic/Agent/Instrumentation/MetricFrame/Pop.html#method-i-traced-3F","()",""],["traced?","NewRelic::Agent::MethodTracer::InstanceMethods::TraceExecutionScoped","NewRelic/Agent/MethodTracer/InstanceMethods/TraceExecutionScoped.html#method-i-traced-3F","()","<p>Shorthand to return the status of tracing\n"],["traced_method_exists?","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-traced_method_exists-3F","(method_name, metric_name_code)","<p>Checks to see if we have already traced a method with a given metric by\nchecking to see if the traced …\n"],["transaction_data","NewRelic::Agent::SqlSampler","NewRelic/Agent/SqlSampler.html#method-i-transaction_data","()",""],["transaction_sampler=","NewRelic::Agent::StatsEngine::Transactions","NewRelic/Agent/StatsEngine/Transactions.html#method-i-transaction_sampler-3D","(sampler)","<p>add a new transaction sampler, unless we’re currently in a transaction\n(then we fail)\n"],["tried_to_connect?","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-tried_to_connect-3F","(options)","<p>We’ve tried to connect if @connected is not nil, or if we are forcing\nreconnection (i.e. in the case …\n"],["truncate","NewRelic::TransactionSample","NewRelic/TransactionSample.html#method-i-truncate","(max)","<p>Truncates the transaction sample to a maximum length determined by the\npassed-in parameter. Operates …\n"],["truncate","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-truncate","(max)","<p>Walk through the tree and truncate the segments in a depth-first manner\n"],["truncate!","NewRelic::MetricSpec","NewRelic/MetricSpec.html#method-i-truncate-21","()","<p>truncates the name and scope to the MAX_LENGTH\n"],["truncate_each_child","NewRelic::TransactionSample::Segment","NewRelic/TransactionSample/Segment.html#method-i-truncate_each_child","(max)",""],["truncate_message","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-truncate_message","(message)","<p>Truncates the message to `MAX_DATA_LENGTH` if needed, and appends an\nellipsis because it makes the trucation …\n"],["truncate_samples","NewRelic::Agent::TransactionSampler","NewRelic/Agent/TransactionSampler.html#method-i-truncate_samples","()","<p>Smashes the @samples array down to the length of @max_samples by taking the\nlast @max_samples elements …\n"],["ui_name","NewRelic::TransactionAnalysis::SegmentSummary","NewRelic/TransactionAnalysis/SegmentSummary.html#method-i-ui_name","()",""],["unrecognized_keys","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-unrecognized_keys","(expected, given)","<p>used to verify that the keys passed to\nNewRelic::Agent::MethodTracer::ClassMethods#add_method_tracer …\n"],["unsent_errors_size","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-unsent_errors_size","()","<p>Returns the length of the unsent errors array, if it exists, otherwise nil\n"],["unsent_timeslice_data","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-unsent_timeslice_data","()","<p>Initializes the unsent timeslice data hash, if needed, and returns the\nnumber of keys it contains\n"],["unsent_traces_size","NewRelic::Agent::Agent::InstanceMethods","NewRelic/Agent/Agent/InstanceMethods.html#method-i-unsent_traces_size","()","<p>Returns the length of the traces array, if it exists, otherwise nil\n"],["update_apdex","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-update_apdex","(stat, duration, failed)","<p>Record an apdex value for the given stat.  when `failed` the apdex should\nbe recorded as a failure regardless …\n"],["update_boundaries","NewRelic::Stats","NewRelic/Stats.html#method-i-update_boundaries","(other)",""],["update_last_sent!","NewRelic::DataSerialization::ClassMethods","NewRelic/DataSerialization/ClassMethods.html#method-i-update_last_sent-21","()","<p>touches the age file that determines whether we should send data now or not\n"],["update_totals","NewRelic::Stats","NewRelic/Stats.html#method-i-update_totals","(other)",""],["uri","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-uri","()","<p>For the current web transaction, return the path of the URI minus the host\npart and query string, or …\n"],["uri_from_request","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-uri_from_request","(request)","<p>Make a safe attempt to get the URI, without the host and query string.\n"],["uri_ref_and_root","NewRelic::Agent::ErrorCollector::NoticeError","NewRelic/Agent/ErrorCollector/NoticeError.html#method-i-uri_ref_and_root","(options)","<p>returns some basic option defaults pulled from the provided options hash\n"],["use_harvest_sampler?","NewRelic::Agent::Sampler","NewRelic/Agent/Sampler.html#method-c-use_harvest_sampler-3F","()","<p>Override to use the periodic sampler instead of running the sampler on the\nminute during harvests.\n"],["use_ssl?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-use_ssl-3F","()",""],["use_textmate?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-use_textmate-3F","()","<p>True if we should view files in textmate\n"],["user_attributes","NewRelic::Agent::BrowserMonitoring::DummyMetricFrame","NewRelic/Agent/BrowserMonitoring/DummyMetricFrame.html#method-i-user_attributes","()",""],["user_attributes","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-user_attributes","()",""],["user_attributes","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-c-user_attributes","()",""],["user_util_stats","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-i-user_util_stats","()",""],["usertime_stats","NewRelic::Agent::Samplers::CpuSampler","NewRelic/Agent/Samplers/CpuSampler.html#method-i-usertime_stats","()",""],["using_engine?","NewRelic::LanguageSupport","NewRelic/LanguageSupport.html#method-i-using_engine-3F","(engine)",""],["using_forking_dispatcher?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-using_forking_dispatcher-3F","()","<p>If we’re using a dispatcher that forks before serving requests, we need\nto wait until the children are …\n"],["using_sinatra?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-using_sinatra-3F","()","<p>If we’re using sinatra, old versions run in an at_exit block so we should\nprobably know that\n"],["using_version?","NewRelic::LanguageSupport","NewRelic/LanguageSupport.html#method-i-using_version-3F","(version)",""],["validate_options","NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer","NewRelic/Agent/MethodTracer/ClassMethods/AddMethodTracer.html#method-i-validate_options","(options)","<p>Checks the provided options to make sure that they make sense. Raises an\nerror if the options are incorrect …\n"],["validate_seed","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-validate_seed","()",""],["validate_settings","NewRelic::Agent::Agent::InstanceMethods::Connect","NewRelic/Agent/Agent/InstanceMethods/Connect.html#method-i-validate_settings","()","<p>These validation settings are used for cases where a dynamic server is spun\nup for clients - partners …\n"],["validate_token","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-validate_token","()",""],["vendor_root","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-vendor_root","()",""],["verify_certificate?","NewRelic::Control::Configuration","NewRelic/Control/Configuration.html#method-i-verify_certificate-3F","()","<p>only verify certificates if you’re very sure you want this level of\nsecurity, it includes possibly app-crashing …\n"],["version","NewRelic::Control::Frameworks::Rails3","NewRelic/Control/Frameworks/Rails3.html#method-i-version","()",""],["weird_ruby?","NewRelic::Agent::Agent::InstanceMethods::Start","NewRelic/Agent/Agent/InstanceMethods/Start.html#method-i-weird_ruby-3F","()","<p>we should not set an at_exit block if people are using these as they\ndon’t do standard at_exit behavior …\n"],["with_database_metric_name","NewRelic::Agent","NewRelic/Agent.html#method-i-with_database_metric_name","(model, method, &block)","<p>Yield to a block that is run with a database metric name context.  This\nmeans the Database instrumentation …\n"],["with_database_metric_name","NewRelic::Agent::Instrumentation::MetricFrame","NewRelic/Agent/Instrumentation/MetricFrame.html#method-i-with_database_metric_name","(model, method)","<p>Yield to a block that is run with a database metric name context.  This\nmeans the Database instrumentation …\n"],["worker_name","NewRelic::Agent::Samplers::DelayedJobLockSampler","NewRelic/Agent/Samplers/DelayedJobLockSampler.html#method-i-worker_name","()",""],["working_jruby?","NewRelic::LocalEnvironment","NewRelic/LocalEnvironment.html#method-i-working_jruby-3F","()","<p>it’s a working jruby if it has the runtime method, and object space is\nenabled\n"],["CHANGELOG","","CHANGELOG.html","","<p>v3.3.0\n\n<pre>* fix for GC instrumentation when using Ruby 1.9\n* new feature to correlate browser and server ...</pre>\n"],["LICENSE","","LICENSE.html","","<p>This product includes jquery written by John Resig and distributed under an\nMIT license. See github.com/jquery/jquery/blob/master/MIT-LICENSE.txt …\n"],["README","","README_rdoc.html","","<p>New Relic Ruby Agent\n<p>New Relic is a performance management system, developed by New Relic, Inc\n(www.newrelic.com …\n"]]}}